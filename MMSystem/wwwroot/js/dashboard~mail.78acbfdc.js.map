{"version":3,"sources":["webpack:///./node_modules/@microsoft/signalr/dist/esm/ILogger.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/Utils.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/DefaultReconnectPolicy.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/Errors.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/HttpClient.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/ITransport.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/FetchHttpClient.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/XhrHttpClient.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/DefaultHttpClient.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/HeaderNames.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/AbortController.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/LongPollingTransport.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/ServerSentEventsTransport.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/WebSocketTransport.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/HttpConnection.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/TextMessageFormat.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/HandshakeProtocol.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/IHubProtocol.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/Subject.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/HubConnection.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/JsonHubProtocol.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/HubConnectionBuilder.js","webpack:///./node_modules/@microsoft/signalr/dist/esm/Loggers.js","webpack:///./src/components/navComponent.vue?fc7b","webpack:///src/components/navComponent.vue","webpack:///./src/components/navComponent.vue?bf75","webpack:///./src/components/navComponent.vue"],"names":["LogLevel","VERSION","Arg","val","name","undefined","Error","match","values","Platform","window","document","self","this","isBrowser","isWebWorker","isReactNative","getDataDetail","data","includeContent","detail","isArrayBuffer","byteLength","formatArrayBuffer","length","view","Uint8Array","str","forEach","num","pad","toString","substr","ArrayBuffer","constructor","async","sendMessage","logger","transportName","httpClient","url","accessTokenFactory","content","options","headers","token","value","getUserAgentHeader","log","Trace","logMessageContent","responseType","response","post","timeout","withCredentials","statusCode","createLogger","ConsoleLogger","Information","instance","SubjectSubscription","subject","observer","_subject","_observer","index","observers","indexOf","splice","cancelCallback","catch","_","minimumLogLevel","_minLevel","out","console","logLevel","message","msg","Date","toISOString","Critical","error","Warning","warn","info","userAgentHeaderName","isNode","constructUserAgent","getOsName","getRuntime","getRuntimeVersion","version","os","runtime","runtimeVersion","userAgent","majorAndMinor","split","process","platform","versions","node","getErrorString","e","stack","getGlobalThis","globalThis","global","DEFAULT_RETRY_DELAYS_IN_MILLISECONDS","DefaultReconnectPolicy","retryDelays","_retryDelays","retryContext","previousRetryCount","HttpError","errorMessage","trueProto","prototype","super","__proto__","TimeoutError","AbortError","UnsupportedTransportError","transport","errorType","DisabledTransportError","FailedToStartTransportError","FailedToNegotiateWithServerError","AggregateErrors","innerErrors","HttpResponse","statusText","HttpClient","send","method","HttpTransportType","TransferFormat","_logger","fetch","requireFunc","_jar","CookieJar","_fetchType","bind","AbortController","_abortControllerType","request","abortSignal","aborted","abortController","onabort","abort","timeoutId","msTimeout","setTimeout","body","cache","credentials","mode","redirect","signal","clearTimeout","ok","deserializeContent","status","payload","cookies","getCookies","c","join","arrayBuffer","text","Promise","reject","resolve","xhr","XMLHttpRequest","open","setRequestHeader","Object","keys","header","onload","responseText","onerror","ontimeout","_httpClient","getCookieString","HeaderNames","Authorization","Cookie","_isAborted","_accessTokenFactory","_pollAbort","_options","_running","onreceive","onclose","transferFormat","isRequired","isIn","_url","Binary","pollOptions","_getAccessToken","_updateHeaderToken","pollUrl","now","get","_closeError","_receiving","_poll","pollAborted","_raiseOnClose","deleteOptions","delete","logMessage","encodeURIComponent","eventSource","opened","Text","EventSource","onmessage","_close","onopen","_eventSource","close","webSocketConstructor","_logMessageContent","_webSocketConstructor","_headers","webSocket","replace","binaryType","_event","_webSocket","event","ErrorEvent","readyState","OPEN","_isCloseEvent","wasClean","code","reason","MAX_REDIRECTS","_stopPromiseResolver","features","_negotiateVersion","baseUrl","_resolveUrl","webSocketModule","eventSourceModule","WebSocket","_connectionState","_connectionStarted","Debug","_startInternalPromise","_startInternal","_stopPromise","_sendQueue","TransportSendQueue","_stopInternal","_stopError","stop","_stopConnection","skipNegotiation","WebSockets","_constructTransport","_startTransport","negotiateResponse","redirects","_getNegotiationResponse","ProtocolVersion","accessToken","_createTransport","inherentKeepAlive","negotiateUrl","_resolveNegotiateUrl","JSON","parse","negotiateVersion","connectionToken","connectionId","requestedTransport","requestedTransferFormat","connectUrl","_createConnectUrl","_isITransport","transportExceptions","transports","availableTransports","negotiate","endpoint","transportOrError","_resolveTransportOrError","push","ex","ServerSentEvents","LongPolling","connect","transportMatches","transferFormats","map","s","lastIndexOf","aTag","createElement","href","substring","actualTransport","_transport","_buffer","_executing","_sendBufferedData","PromiseSource","_transportResult","_sendLoopPromise","_sendLoop","_bufferData","promise","transportResult","_concatBuffers","arrayBuffers","totalLength","b","reduce","a","result","offset","item","set","buffer","_resolver","_rejecter","TextMessageFormat","output","RecordSeparator","input","messages","pop","RecordSeparatorCode","String","fromCharCode","handshakeRequest","write","stringify","messageData","remainingData","binaryData","separatorIndex","responseLength","apply","Array","slice","call","textData","type","responseMessage","MessageType","next","err","complete","DEFAULT_TIMEOUT_IN_MS","DEFAULT_PING_INTERVAL_IN_MS","HubConnectionState","connection","protocol","reconnectPolicy","_nextKeepAlive","_freezeEventListener","serverTimeoutInMilliseconds","keepAliveIntervalInMilliseconds","_protocol","_reconnectPolicy","_handshakeProtocol","_processIncomingData","_connectionClosed","_callbacks","_methods","_closedCallbacks","_reconnectingCallbacks","_reconnectedCallbacks","_invocationId","_receivedHandshakeResponse","Disconnected","_cachedPingMessage","writeMessage","Ping","Reconnecting","_startPromise","_startWithStateTransitions","Connecting","addEventListener","Connected","_stopDuringStartError","handshakePromise","_handshakeResolver","_handshakeRejecter","start","_sendMessage","writeHandshakeRequest","_cleanupTimeout","_resetTimeoutPeriod","_resetKeepAliveInterval","_cleanupPingTimer","startPromise","Disconnecting","_reconnectDelayHandle","_completeClose","methodName","args","streams","streamIds","_replaceStreamingParams","invocationDescriptor","_createStreamInvocation","promiseQueue","cancelInvocation","_createCancelInvocation","invocationId","then","_sendWithProtocol","invocationEvent","Completion","_launchStreams","sendPromise","_createInvocation","p","newMethod","toLowerCase","handlers","removeIdx","callback","_processHandshakeResponse","parseMessages","Invocation","_invokeClientMethod","StreamItem","Close","allowReconnect","parseHandshakeResponse","getTime","_timeoutHandle","serverTimeout","_pingServerHandle","nextPing","invocationMessage","methods","target","m","arguments","_cancelCallbacksWithError","_reconnect","removeEventListener","reconnectStartTime","previousReconnectAttempts","retryError","nextRetryDelay","_getNextRetryDelay","elapsedMilliseconds","retryReason","nextRetryDelayInMilliseconds","callbacks","key","nonblocking","streamId","subscribe","_createCompletionMessage","_createStreamItemMessage","i","argument","_isObservable","arg","StreamInvocation","id","CancelInvocation","JSON_HUB_PROTOCOL_NAME","hubMessages","parsedMessage","_isInvocationMessage","_isStreamItemMessage","_isCompletionMessage","_assertNotEmptyString","LogLevelNameMapping","trace","debug","information","warning","critical","none","None","parseLogLevel","mapping","logging","isLogger","transportTypeOrOptions","isNotEmpty","httpConnectionOptions","retryDelaysOrReconnectPolicy","isArray","create","NullLogger","_logLevel","_message","render","_vm","_h","$createElement","_c","_self","staticClass","on","$event","toggleMenu","_v","attrs","roles","includes","_e","Logout","staticRenderFns","mounted","localStorage","getItem","$router","date","year","getFullYear","my_user_id","my_department_id","userProcedure","searchMenu","closeSearchMenu","searchFor","resultOfSearch","finacial_recipt_number","transaction_number","mailType","removeItem","search","$http","TransactionsService","ayoub","canselSearch","toggle_menu","querySelector","classList","toggle","getElementById","toggle_search","component"],"mappings":"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","file":"js/dashboard~mail.78acbfdc.js","sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.\r\n/** Indicates the severity of a log message.\r\n *\r\n * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.\r\n */\r\nexport var LogLevel;\r\n(function (LogLevel) {\r\n    /** Log level for very low severity diagnostic messages. */\r\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\r\n    /** Log level for low severity diagnostic messages. */\r\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\r\n    /** Log level for informational diagnostic messages. */\r\n    LogLevel[LogLevel[\"Information\"] = 2] = \"Information\";\r\n    /** Log level for diagnostic messages that indicate a non-fatal problem. */\r\n    LogLevel[LogLevel[\"Warning\"] = 3] = \"Warning\";\r\n    /** Log level for diagnostic messages that indicate a failure in the current operation. */\r\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\r\n    /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */\r\n    LogLevel[LogLevel[\"Critical\"] = 5] = \"Critical\";\r\n    /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */\r\n    LogLevel[LogLevel[\"None\"] = 6] = \"None\";\r\n})(LogLevel || (LogLevel = {}));\r\n//# sourceMappingURL=ILogger.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { NullLogger } from \"./Loggers\";\r\n// Version token that will be replaced by the prepack command\r\n/** The version of the SignalR client. */\r\nexport const VERSION = \"6.0.4\";\r\n/** @private */\r\nexport class Arg {\r\n    static isRequired(val, name) {\r\n        if (val === null || val === undefined) {\r\n            throw new Error(`The '${name}' argument is required.`);\r\n        }\r\n    }\r\n    static isNotEmpty(val, name) {\r\n        if (!val || val.match(/^\\s*$/)) {\r\n            throw new Error(`The '${name}' argument should not be empty.`);\r\n        }\r\n    }\r\n    static isIn(val, values, name) {\r\n        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\r\n        if (!(val in values)) {\r\n            throw new Error(`Unknown ${name} value: ${val}.`);\r\n        }\r\n    }\r\n}\r\n/** @private */\r\nexport class Platform {\r\n    // react-native has a window but no document so we should check both\r\n    static get isBrowser() {\r\n        return typeof window === \"object\" && typeof window.document === \"object\";\r\n    }\r\n    // WebWorkers don't have a window object so the isBrowser check would fail\r\n    static get isWebWorker() {\r\n        return typeof self === \"object\" && \"importScripts\" in self;\r\n    }\r\n    // react-native has a window but no document\r\n    static get isReactNative() {\r\n        return typeof window === \"object\" && typeof window.document === \"undefined\";\r\n    }\r\n    // Node apps shouldn't have a window object, but WebWorkers don't either\r\n    // so we need to check for both WebWorker and window\r\n    static get isNode() {\r\n        return !this.isBrowser && !this.isWebWorker && !this.isReactNative;\r\n    }\r\n}\r\n/** @private */\r\nexport function getDataDetail(data, includeContent) {\r\n    let detail = \"\";\r\n    if (isArrayBuffer(data)) {\r\n        detail = `Binary data of length ${data.byteLength}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${formatArrayBuffer(data)}'`;\r\n        }\r\n    }\r\n    else if (typeof data === \"string\") {\r\n        detail = `String data of length ${data.length}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${data}'`;\r\n        }\r\n    }\r\n    return detail;\r\n}\r\n/** @private */\r\nexport function formatArrayBuffer(data) {\r\n    const view = new Uint8Array(data);\r\n    // Uint8Array.map only supports returning another Uint8Array?\r\n    let str = \"\";\r\n    view.forEach((num) => {\r\n        const pad = num < 16 ? \"0\" : \"\";\r\n        str += `0x${pad}${num.toString(16)} `;\r\n    });\r\n    // Trim of trailing space.\r\n    return str.substr(0, str.length - 1);\r\n}\r\n// Also in signalr-protocol-msgpack/Utils.ts\r\n/** @private */\r\nexport function isArrayBuffer(val) {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}\r\n/** @private */\r\nexport async function sendMessage(logger, transportName, httpClient, url, accessTokenFactory, content, options) {\r\n    let headers = {};\r\n    if (accessTokenFactory) {\r\n        const token = await accessTokenFactory();\r\n        if (token) {\r\n            headers = {\r\n                [\"Authorization\"]: `Bearer ${token}`,\r\n            };\r\n        }\r\n    }\r\n    const [name, value] = getUserAgentHeader();\r\n    headers[name] = value;\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) sending data. ${getDataDetail(content, options.logMessageContent)}.`);\r\n    const responseType = isArrayBuffer(content) ? \"arraybuffer\" : \"text\";\r\n    const response = await httpClient.post(url, {\r\n        content,\r\n        headers: { ...headers, ...options.headers },\r\n        responseType,\r\n        timeout: options.timeout,\r\n        withCredentials: options.withCredentials,\r\n    });\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) request complete. Response status: ${response.statusCode}.`);\r\n}\r\n/** @private */\r\nexport function createLogger(logger) {\r\n    if (logger === undefined) {\r\n        return new ConsoleLogger(LogLevel.Information);\r\n    }\r\n    if (logger === null) {\r\n        return NullLogger.instance;\r\n    }\r\n    if (logger.log !== undefined) {\r\n        return logger;\r\n    }\r\n    return new ConsoleLogger(logger);\r\n}\r\n/** @private */\r\nexport class SubjectSubscription {\r\n    constructor(subject, observer) {\r\n        this._subject = subject;\r\n        this._observer = observer;\r\n    }\r\n    dispose() {\r\n        const index = this._subject.observers.indexOf(this._observer);\r\n        if (index > -1) {\r\n            this._subject.observers.splice(index, 1);\r\n        }\r\n        if (this._subject.observers.length === 0 && this._subject.cancelCallback) {\r\n            this._subject.cancelCallback().catch((_) => { });\r\n        }\r\n    }\r\n}\r\n/** @private */\r\nexport class ConsoleLogger {\r\n    constructor(minimumLogLevel) {\r\n        this._minLevel = minimumLogLevel;\r\n        this.out = console;\r\n    }\r\n    log(logLevel, message) {\r\n        if (logLevel >= this._minLevel) {\r\n            const msg = `[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`;\r\n            switch (logLevel) {\r\n                case LogLevel.Critical:\r\n                case LogLevel.Error:\r\n                    this.out.error(msg);\r\n                    break;\r\n                case LogLevel.Warning:\r\n                    this.out.warn(msg);\r\n                    break;\r\n                case LogLevel.Information:\r\n                    this.out.info(msg);\r\n                    break;\r\n                default:\r\n                    // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\r\n                    this.out.log(msg);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n/** @private */\r\nexport function getUserAgentHeader() {\r\n    let userAgentHeaderName = \"X-SignalR-User-Agent\";\r\n    if (Platform.isNode) {\r\n        userAgentHeaderName = \"User-Agent\";\r\n    }\r\n    return [userAgentHeaderName, constructUserAgent(VERSION, getOsName(), getRuntime(), getRuntimeVersion())];\r\n}\r\n/** @private */\r\nexport function constructUserAgent(version, os, runtime, runtimeVersion) {\r\n    // Microsoft SignalR/[Version] ([Detailed Version]; [Operating System]; [Runtime]; [Runtime Version])\r\n    let userAgent = \"Microsoft SignalR/\";\r\n    const majorAndMinor = version.split(\".\");\r\n    userAgent += `${majorAndMinor[0]}.${majorAndMinor[1]}`;\r\n    userAgent += ` (${version}; `;\r\n    if (os && os !== \"\") {\r\n        userAgent += `${os}; `;\r\n    }\r\n    else {\r\n        userAgent += \"Unknown OS; \";\r\n    }\r\n    userAgent += `${runtime}`;\r\n    if (runtimeVersion) {\r\n        userAgent += `; ${runtimeVersion}`;\r\n    }\r\n    else {\r\n        userAgent += \"; Unknown Runtime Version\";\r\n    }\r\n    userAgent += \")\";\r\n    return userAgent;\r\n}\r\n// eslint-disable-next-line spaced-comment\r\n/*#__PURE__*/ function getOsName() {\r\n    if (Platform.isNode) {\r\n        switch (process.platform) {\r\n            case \"win32\":\r\n                return \"Windows NT\";\r\n            case \"darwin\":\r\n                return \"macOS\";\r\n            case \"linux\":\r\n                return \"Linux\";\r\n            default:\r\n                return process.platform;\r\n        }\r\n    }\r\n    else {\r\n        return \"\";\r\n    }\r\n}\r\n// eslint-disable-next-line spaced-comment\r\n/*#__PURE__*/ function getRuntimeVersion() {\r\n    if (Platform.isNode) {\r\n        return process.versions.node;\r\n    }\r\n    return undefined;\r\n}\r\nfunction getRuntime() {\r\n    if (Platform.isNode) {\r\n        return \"NodeJS\";\r\n    }\r\n    else {\r\n        return \"Browser\";\r\n    }\r\n}\r\n/** @private */\r\nexport function getErrorString(e) {\r\n    if (e.stack) {\r\n        return e.stack;\r\n    }\r\n    else if (e.message) {\r\n        return e.message;\r\n    }\r\n    return `${e}`;\r\n}\r\n/** @private */\r\nexport function getGlobalThis() {\r\n    // globalThis is semi-new and not available in Node until v12\r\n    if (typeof globalThis !== \"undefined\") {\r\n        return globalThis;\r\n    }\r\n    if (typeof self !== \"undefined\") {\r\n        return self;\r\n    }\r\n    if (typeof window !== \"undefined\") {\r\n        return window;\r\n    }\r\n    if (typeof global !== \"undefined\") {\r\n        return global;\r\n    }\r\n    throw new Error(\"could not find global\");\r\n}\r\n//# sourceMappingURL=Utils.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// 0, 2, 10, 30 second delays before reconnect attempts.\r\nconst DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];\r\n/** @private */\r\nexport class DefaultReconnectPolicy {\r\n    constructor(retryDelays) {\r\n        this._retryDelays = retryDelays !== undefined ? [...retryDelays, null] : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;\r\n    }\r\n    nextRetryDelayInMilliseconds(retryContext) {\r\n        return this._retryDelays[retryContext.previousRetryCount];\r\n    }\r\n}\r\n//# sourceMappingURL=DefaultReconnectPolicy.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n/** Error thrown when an HTTP request fails. */\r\nexport class HttpError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     * @param {number} statusCode The HTTP status code represented by this error.\r\n     */\r\n    constructor(errorMessage, statusCode) {\r\n        const trueProto = new.target.prototype;\r\n        super(`${errorMessage}: Status code '${statusCode}'`);\r\n        this.statusCode = statusCode;\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when a timeout elapses. */\r\nexport class TimeoutError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage = \"A timeout occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when an action is aborted. */\r\nexport class AbortError extends Error {\r\n    /** Constructs a new instance of {@link AbortError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage = \"An abort occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when the selected transport is unsupported by the browser. */\r\n/** @private */\r\nexport class UnsupportedTransportError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.UnsupportedTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occured on.\r\n     */\r\n    constructor(message, transport) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'UnsupportedTransportError';\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when the selected transport is disabled by the browser. */\r\n/** @private */\r\nexport class DisabledTransportError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.DisabledTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occured on.\r\n     */\r\n    constructor(message, transport) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'DisabledTransportError';\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when the selected transport cannot be started. */\r\n/** @private */\r\nexport class FailedToStartTransportError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.FailedToStartTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occured on.\r\n     */\r\n    constructor(message, transport) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'FailedToStartTransportError';\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when the negotiation with the server failed to complete. */\r\n/** @private */\r\nexport class FailedToNegotiateWithServerError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.FailedToNegotiateWithServerError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     */\r\n    constructor(message) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.errorType = 'FailedToNegotiateWithServerError';\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when multiple errors have occured. */\r\n/** @private */\r\nexport class AggregateErrors extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.AggregateErrors}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {Error[]} innerErrors The collection of errors this error is aggregating.\r\n     */\r\n    constructor(message, innerErrors) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.innerErrors = innerErrors;\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n//# sourceMappingURL=Errors.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n/** Represents an HTTP response. */\r\nexport class HttpResponse {\r\n    constructor(statusCode, statusText, content) {\r\n        this.statusCode = statusCode;\r\n        this.statusText = statusText;\r\n        this.content = content;\r\n    }\r\n}\r\n/** Abstraction over an HTTP client.\r\n *\r\n * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.\r\n */\r\nexport class HttpClient {\r\n    get(url, options) {\r\n        return this.send({\r\n            ...options,\r\n            method: \"GET\",\r\n            url,\r\n        });\r\n    }\r\n    post(url, options) {\r\n        return this.send({\r\n            ...options,\r\n            method: \"POST\",\r\n            url,\r\n        });\r\n    }\r\n    delete(url, options) {\r\n        return this.send({\r\n            ...options,\r\n            method: \"DELETE\",\r\n            url,\r\n        });\r\n    }\r\n    /** Gets all cookies that apply to the specified URL.\r\n     *\r\n     * @param url The URL that the cookies are valid for.\r\n     * @returns {string} A string containing all the key-value cookie pairs for the specified URL.\r\n     */\r\n    // @ts-ignore\r\n    getCookieString(url) {\r\n        return \"\";\r\n    }\r\n}\r\n//# sourceMappingURL=HttpClient.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// This will be treated as a bit flag in the future, so we keep it using power-of-two values.\r\n/** Specifies a specific HTTP transport type. */\r\nexport var HttpTransportType;\r\n(function (HttpTransportType) {\r\n    /** Specifies no transport preference. */\r\n    HttpTransportType[HttpTransportType[\"None\"] = 0] = \"None\";\r\n    /** Specifies the WebSockets transport. */\r\n    HttpTransportType[HttpTransportType[\"WebSockets\"] = 1] = \"WebSockets\";\r\n    /** Specifies the Server-Sent Events transport. */\r\n    HttpTransportType[HttpTransportType[\"ServerSentEvents\"] = 2] = \"ServerSentEvents\";\r\n    /** Specifies the Long Polling transport. */\r\n    HttpTransportType[HttpTransportType[\"LongPolling\"] = 4] = \"LongPolling\";\r\n})(HttpTransportType || (HttpTransportType = {}));\r\n/** Specifies the transfer format for a connection. */\r\nexport var TransferFormat;\r\n(function (TransferFormat) {\r\n    /** Specifies that only text data will be transmitted over the connection. */\r\n    TransferFormat[TransferFormat[\"Text\"] = 1] = \"Text\";\r\n    /** Specifies that binary data will be transmitted over the connection. */\r\n    TransferFormat[TransferFormat[\"Binary\"] = 2] = \"Binary\";\r\n})(TransferFormat || (TransferFormat = {}));\r\n//# sourceMappingURL=ITransport.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpResponse } from \"./HttpClient\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { Platform, getGlobalThis } from \"./Utils\";\r\nexport class FetchHttpClient extends HttpClient {\r\n    constructor(logger) {\r\n        super();\r\n        this._logger = logger;\r\n        if (typeof fetch === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\r\n            this._jar = new (requireFunc(\"tough-cookie\")).CookieJar();\r\n            this._fetchType = requireFunc(\"node-fetch\");\r\n            // node-fetch doesn't have a nice API for getting and setting cookies\r\n            // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\r\n            this._fetchType = requireFunc(\"fetch-cookie\")(this._fetchType, this._jar);\r\n        }\r\n        else {\r\n            this._fetchType = fetch.bind(getGlobalThis());\r\n        }\r\n        if (typeof AbortController === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\r\n            this._abortControllerType = requireFunc(\"abort-controller\");\r\n        }\r\n        else {\r\n            this._abortControllerType = AbortController;\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    async send(request) {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            throw new AbortError();\r\n        }\r\n        if (!request.method) {\r\n            throw new Error(\"No method defined.\");\r\n        }\r\n        if (!request.url) {\r\n            throw new Error(\"No url defined.\");\r\n        }\r\n        const abortController = new this._abortControllerType();\r\n        let error;\r\n        // Hook our abortSignal into the abort controller\r\n        if (request.abortSignal) {\r\n            request.abortSignal.onabort = () => {\r\n                abortController.abort();\r\n                error = new AbortError();\r\n            };\r\n        }\r\n        // If a timeout has been passed in, setup a timeout to call abort\r\n        // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\r\n        let timeoutId = null;\r\n        if (request.timeout) {\r\n            const msTimeout = request.timeout;\r\n            timeoutId = setTimeout(() => {\r\n                abortController.abort();\r\n                this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                error = new TimeoutError();\r\n            }, msTimeout);\r\n        }\r\n        let response;\r\n        try {\r\n            response = await this._fetchType(request.url, {\r\n                body: request.content,\r\n                cache: \"no-cache\",\r\n                credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\r\n                headers: {\r\n                    \"Content-Type\": \"text/plain;charset=UTF-8\",\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                    ...request.headers,\r\n                },\r\n                method: request.method,\r\n                mode: \"cors\",\r\n                redirect: \"follow\",\r\n                signal: abortController.signal,\r\n            });\r\n        }\r\n        catch (e) {\r\n            if (error) {\r\n                throw error;\r\n            }\r\n            this._logger.log(LogLevel.Warning, `Error from HTTP request. ${e}.`);\r\n            throw e;\r\n        }\r\n        finally {\r\n            if (timeoutId) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = null;\r\n            }\r\n        }\r\n        if (!response.ok) {\r\n            const errorMessage = await deserializeContent(response, \"text\");\r\n            throw new HttpError(errorMessage || response.statusText, response.status);\r\n        }\r\n        const content = deserializeContent(response, request.responseType);\r\n        const payload = await content;\r\n        return new HttpResponse(response.status, response.statusText, payload);\r\n    }\r\n    getCookieString(url) {\r\n        let cookies = \"\";\r\n        if (Platform.isNode && this._jar) {\r\n            // @ts-ignore: unused variable\r\n            this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\r\n        }\r\n        return cookies;\r\n    }\r\n}\r\nfunction deserializeContent(response, responseType) {\r\n    let content;\r\n    switch (responseType) {\r\n        case \"arraybuffer\":\r\n            content = response.arrayBuffer();\r\n            break;\r\n        case \"text\":\r\n            content = response.text();\r\n            break;\r\n        case \"blob\":\r\n        case \"document\":\r\n        case \"json\":\r\n            throw new Error(`${responseType} is not supported.`);\r\n        default:\r\n            content = response.text();\r\n            break;\r\n    }\r\n    return content;\r\n}\r\n//# sourceMappingURL=FetchHttpClient.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpResponse } from \"./HttpClient\";\r\nimport { LogLevel } from \"./ILogger\";\r\nexport class XhrHttpClient extends HttpClient {\r\n    constructor(logger) {\r\n        super();\r\n        this._logger = logger;\r\n    }\r\n    /** @inheritDoc */\r\n    send(request) {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            const xhr = new XMLHttpRequest();\r\n            xhr.open(request.method, request.url, true);\r\n            xhr.withCredentials = request.withCredentials === undefined ? true : request.withCredentials;\r\n            xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\r\n            // Explicitly setting the Content-Type header for React Native on Android platform.\r\n            xhr.setRequestHeader(\"Content-Type\", \"text/plain;charset=UTF-8\");\r\n            const headers = request.headers;\r\n            if (headers) {\r\n                Object.keys(headers)\r\n                    .forEach((header) => {\r\n                    xhr.setRequestHeader(header, headers[header]);\r\n                });\r\n            }\r\n            if (request.responseType) {\r\n                xhr.responseType = request.responseType;\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = () => {\r\n                    xhr.abort();\r\n                    reject(new AbortError());\r\n                };\r\n            }\r\n            if (request.timeout) {\r\n                xhr.timeout = request.timeout;\r\n            }\r\n            xhr.onload = () => {\r\n                if (request.abortSignal) {\r\n                    request.abortSignal.onabort = null;\r\n                }\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(new HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));\r\n                }\r\n                else {\r\n                    reject(new HttpError(xhr.response || xhr.responseText || xhr.statusText, xhr.status));\r\n                }\r\n            };\r\n            xhr.onerror = () => {\r\n                this._logger.log(LogLevel.Warning, `Error from HTTP request. ${xhr.status}: ${xhr.statusText}.`);\r\n                reject(new HttpError(xhr.statusText, xhr.status));\r\n            };\r\n            xhr.ontimeout = () => {\r\n                this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                reject(new TimeoutError());\r\n            };\r\n            xhr.send(request.content || \"\");\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=XhrHttpClient.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AbortError } from \"./Errors\";\r\nimport { FetchHttpClient } from \"./FetchHttpClient\";\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { Platform } from \"./Utils\";\r\nimport { XhrHttpClient } from \"./XhrHttpClient\";\r\n/** Default implementation of {@link @microsoft/signalr.HttpClient}. */\r\nexport class DefaultHttpClient extends HttpClient {\r\n    /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */\r\n    constructor(logger) {\r\n        super();\r\n        if (typeof fetch !== \"undefined\" || Platform.isNode) {\r\n            this._httpClient = new FetchHttpClient(logger);\r\n        }\r\n        else if (typeof XMLHttpRequest !== \"undefined\") {\r\n            this._httpClient = new XhrHttpClient(logger);\r\n        }\r\n        else {\r\n            throw new Error(\"No usable HttpClient found.\");\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    send(request) {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n        return this._httpClient.send(request);\r\n    }\r\n    getCookieString(url) {\r\n        return this._httpClient.getCookieString(url);\r\n    }\r\n}\r\n//# sourceMappingURL=DefaultHttpClient.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nexport class HeaderNames {\r\n}\r\nHeaderNames.Authorization = \"Authorization\";\r\nHeaderNames.Cookie = \"Cookie\";\r\n//# sourceMappingURL=HeaderNames.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController\r\n// We don't actually ever use the API being polyfilled, we always use the polyfill because\r\n// it's a very new API right now.\r\n// Not exported from index.\r\n/** @private */\r\nexport class AbortController {\r\n    constructor() {\r\n        this._isAborted = false;\r\n        this.onabort = null;\r\n    }\r\n    abort() {\r\n        if (!this._isAborted) {\r\n            this._isAborted = true;\r\n            if (this.onabort) {\r\n                this.onabort();\r\n            }\r\n        }\r\n    }\r\n    get signal() {\r\n        return this;\r\n    }\r\n    get aborted() {\r\n        return this._isAborted;\r\n    }\r\n}\r\n//# sourceMappingURL=AbortController.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AbortController } from \"./AbortController\";\r\nimport { HttpError, TimeoutError } from \"./Errors\";\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, sendMessage } from \"./Utils\";\r\n// Not exported from 'index', this type is internal.\r\n/** @private */\r\nexport class LongPollingTransport {\r\n    constructor(httpClient, accessTokenFactory, logger, options) {\r\n        this._httpClient = httpClient;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n        this._logger = logger;\r\n        this._pollAbort = new AbortController();\r\n        this._options = options;\r\n        this._running = false;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    // This is an internal type, not exported from 'index' so this is really just internal.\r\n    get pollAborted() {\r\n        return this._pollAbort.aborted;\r\n    }\r\n    async connect(url, transferFormat) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._url = url;\r\n        this._logger.log(LogLevel.Trace, \"(LongPolling transport) Connecting.\");\r\n        // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)\r\n        if (transferFormat === TransferFormat.Binary &&\r\n            (typeof XMLHttpRequest !== \"undefined\" && typeof new XMLHttpRequest().responseType !== \"string\")) {\r\n            throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\r\n        }\r\n        const [name, value] = getUserAgentHeader();\r\n        const headers = { [name]: value, ...this._options.headers };\r\n        const pollOptions = {\r\n            abortSignal: this._pollAbort.signal,\r\n            headers,\r\n            timeout: 100000,\r\n            withCredentials: this._options.withCredentials,\r\n        };\r\n        if (transferFormat === TransferFormat.Binary) {\r\n            pollOptions.responseType = \"arraybuffer\";\r\n        }\r\n        const token = await this._getAccessToken();\r\n        this._updateHeaderToken(pollOptions, token);\r\n        // Make initial long polling request\r\n        // Server uses first long polling request to finish initializing connection and it returns without data\r\n        const pollUrl = `${url}&_=${Date.now()}`;\r\n        this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n        const response = await this._httpClient.get(pollUrl, pollOptions);\r\n        if (response.statusCode !== 200) {\r\n            this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n            // Mark running as false so that the poll immediately ends and runs the close logic\r\n            this._closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n            this._running = false;\r\n        }\r\n        else {\r\n            this._running = true;\r\n        }\r\n        this._receiving = this._poll(this._url, pollOptions);\r\n    }\r\n    async _getAccessToken() {\r\n        if (this._accessTokenFactory) {\r\n            return await this._accessTokenFactory();\r\n        }\r\n        return null;\r\n    }\r\n    _updateHeaderToken(request, token) {\r\n        if (!request.headers) {\r\n            request.headers = {};\r\n        }\r\n        if (token) {\r\n            request.headers[HeaderNames.Authorization] = `Bearer ${token}`;\r\n            return;\r\n        }\r\n        if (request.headers[HeaderNames.Authorization]) {\r\n            delete request.headers[HeaderNames.Authorization];\r\n        }\r\n    }\r\n    async _poll(url, pollOptions) {\r\n        try {\r\n            while (this._running) {\r\n                // We have to get the access token on each poll, in case it changes\r\n                const token = await this._getAccessToken();\r\n                this._updateHeaderToken(pollOptions, token);\r\n                try {\r\n                    const pollUrl = `${url}&_=${Date.now()}`;\r\n                    this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n                    const response = await this._httpClient.get(pollUrl, pollOptions);\r\n                    if (response.statusCode === 204) {\r\n                        this._logger.log(LogLevel.Information, \"(LongPolling transport) Poll terminated by server.\");\r\n                        this._running = false;\r\n                    }\r\n                    else if (response.statusCode !== 200) {\r\n                        this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n                        // Unexpected status code\r\n                        this._closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n                        this._running = false;\r\n                    }\r\n                    else {\r\n                        // Process the response\r\n                        if (response.content) {\r\n                            this._logger.log(LogLevel.Trace, `(LongPolling transport) data received. ${getDataDetail(response.content, this._options.logMessageContent)}.`);\r\n                            if (this.onreceive) {\r\n                                this.onreceive(response.content);\r\n                            }\r\n                        }\r\n                        else {\r\n                            // This is another way timeout manifest.\r\n                            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    if (!this._running) {\r\n                        // Log but disregard errors that occur after stopping\r\n                        this._logger.log(LogLevel.Trace, `(LongPolling transport) Poll errored after shutdown: ${e.message}`);\r\n                    }\r\n                    else {\r\n                        if (e instanceof TimeoutError) {\r\n                            // Ignore timeouts and reissue the poll.\r\n                            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        }\r\n                        else {\r\n                            // Close the connection with the error as the result.\r\n                            this._closeError = e;\r\n                            this._running = false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Polling complete.\");\r\n            // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.\r\n            // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.\r\n            if (!this.pollAborted) {\r\n                this._raiseOnClose();\r\n            }\r\n        }\r\n    }\r\n    async send(data) {\r\n        if (!this._running) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"LongPolling\", this._httpClient, this._url, this._accessTokenFactory, data, this._options);\r\n    }\r\n    async stop() {\r\n        this._logger.log(LogLevel.Trace, \"(LongPolling transport) Stopping polling.\");\r\n        // Tell receiving loop to stop, abort any current request, and then wait for it to finish\r\n        this._running = false;\r\n        this._pollAbort.abort();\r\n        try {\r\n            await this._receiving;\r\n            // Send DELETE to clean up long polling on the server\r\n            this._logger.log(LogLevel.Trace, `(LongPolling transport) sending DELETE request to ${this._url}.`);\r\n            const headers = {};\r\n            const [name, value] = getUserAgentHeader();\r\n            headers[name] = value;\r\n            const deleteOptions = {\r\n                headers: { ...headers, ...this._options.headers },\r\n                timeout: this._options.timeout,\r\n                withCredentials: this._options.withCredentials,\r\n            };\r\n            const token = await this._getAccessToken();\r\n            this._updateHeaderToken(deleteOptions, token);\r\n            await this._httpClient.delete(this._url, deleteOptions);\r\n            this._logger.log(LogLevel.Trace, \"(LongPolling transport) DELETE request sent.\");\r\n        }\r\n        finally {\r\n            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Stop finished.\");\r\n            // Raise close event here instead of in polling\r\n            // It needs to happen after the DELETE request is sent\r\n            this._raiseOnClose();\r\n        }\r\n    }\r\n    _raiseOnClose() {\r\n        if (this.onclose) {\r\n            let logMessage = \"(LongPolling transport) Firing onclose event.\";\r\n            if (this._closeError) {\r\n                logMessage += \" Error: \" + this._closeError;\r\n            }\r\n            this._logger.log(LogLevel.Trace, logMessage);\r\n            this.onclose(this._closeError);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=LongPollingTransport.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\r\n/** @private */\r\nexport class ServerSentEventsTransport {\r\n    constructor(httpClient, accessTokenFactory, logger, options) {\r\n        this._httpClient = httpClient;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n        this._logger = logger;\r\n        this._options = options;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    async connect(url, transferFormat) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n        // set url before accessTokenFactory because this.url is only for send and we set the auth header instead of the query string for send\r\n        this._url = url;\r\n        if (this._accessTokenFactory) {\r\n            const token = await this._accessTokenFactory();\r\n            if (token) {\r\n                url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n            }\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            let opened = false;\r\n            if (transferFormat !== TransferFormat.Text) {\r\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n                return;\r\n            }\r\n            let eventSource;\r\n            if (Platform.isBrowser || Platform.isWebWorker) {\r\n                eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials });\r\n            }\r\n            else {\r\n                // Non-browser passes cookies via the dictionary\r\n                const cookies = this._httpClient.getCookieString(url);\r\n                const headers = {};\r\n                headers.Cookie = cookies;\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n                eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials, headers: { ...headers, ...this._options.headers } });\r\n            }\r\n            try {\r\n                eventSource.onmessage = (e) => {\r\n                    if (this.onreceive) {\r\n                        try {\r\n                            this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent)}.`);\r\n                            this.onreceive(e.data);\r\n                        }\r\n                        catch (error) {\r\n                            this._close(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                };\r\n                // @ts-ignore: not using event on purpose\r\n                eventSource.onerror = (e) => {\r\n                    // EventSource doesn't give any useful information about server side closes.\r\n                    if (opened) {\r\n                        this._close();\r\n                    }\r\n                    else {\r\n                        reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\"\r\n                            + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\"\r\n                            + \" If you have multiple servers check that sticky sessions are enabled.\"));\r\n                    }\r\n                };\r\n                eventSource.onopen = () => {\r\n                    this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`);\r\n                    this._eventSource = eventSource;\r\n                    opened = true;\r\n                    resolve();\r\n                };\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n    async send(data) {\r\n        if (!this._eventSource) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"SSE\", this._httpClient, this._url, this._accessTokenFactory, data, this._options);\r\n    }\r\n    stop() {\r\n        this._close();\r\n        return Promise.resolve();\r\n    }\r\n    _close(e) {\r\n        if (this._eventSource) {\r\n            this._eventSource.close();\r\n            this._eventSource = undefined;\r\n            if (this.onclose) {\r\n                this.onclose(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=ServerSentEventsTransport.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform } from \"./Utils\";\r\n/** @private */\r\nexport class WebSocketTransport {\r\n    constructor(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor, headers) {\r\n        this._logger = logger;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n        this._logMessageContent = logMessageContent;\r\n        this._webSocketConstructor = webSocketConstructor;\r\n        this._httpClient = httpClient;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n        this._headers = headers;\r\n    }\r\n    async connect(url, transferFormat) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\r\n        if (this._accessTokenFactory) {\r\n            const token = await this._accessTokenFactory();\r\n            if (token) {\r\n                url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n            }\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            url = url.replace(/^http/, \"ws\");\r\n            let webSocket;\r\n            const cookies = this._httpClient.getCookieString(url);\r\n            let opened = false;\r\n            if (Platform.isNode) {\r\n                const headers = {};\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n                if (cookies) {\r\n                    headers[HeaderNames.Cookie] = `${cookies}`;\r\n                }\r\n                // Only pass headers when in non-browser environments\r\n                webSocket = new this._webSocketConstructor(url, undefined, {\r\n                    headers: { ...headers, ...this._headers },\r\n                });\r\n            }\r\n            if (!webSocket) {\r\n                // Chrome is not happy with passing 'undefined' as protocol\r\n                webSocket = new this._webSocketConstructor(url);\r\n            }\r\n            if (transferFormat === TransferFormat.Binary) {\r\n                webSocket.binaryType = \"arraybuffer\";\r\n            }\r\n            webSocket.onopen = (_event) => {\r\n                this._logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);\r\n                this._webSocket = webSocket;\r\n                opened = true;\r\n                resolve();\r\n            };\r\n            webSocket.onerror = (event) => {\r\n                let error = null;\r\n                // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                    error = event.error;\r\n                }\r\n                else {\r\n                    error = \"There was an error with the transport\";\r\n                }\r\n                this._logger.log(LogLevel.Information, `(WebSockets transport) ${error}.`);\r\n            };\r\n            webSocket.onmessage = (message) => {\r\n                this._logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this._logMessageContent)}.`);\r\n                if (this.onreceive) {\r\n                    try {\r\n                        this.onreceive(message.data);\r\n                    }\r\n                    catch (error) {\r\n                        this._close(error);\r\n                        return;\r\n                    }\r\n                }\r\n            };\r\n            webSocket.onclose = (event) => {\r\n                // Don't call close handler if connection was never established\r\n                // We'll reject the connect call instead\r\n                if (opened) {\r\n                    this._close(event);\r\n                }\r\n                else {\r\n                    let error = null;\r\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                    if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                        error = event.error;\r\n                    }\r\n                    else {\r\n                        error = \"WebSocket failed to connect. The connection could not be found on the server,\"\r\n                            + \" either the endpoint may not be a SignalR endpoint,\"\r\n                            + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\"\r\n                            + \" If you have multiple servers check that sticky sessions are enabled.\";\r\n                    }\r\n                    reject(new Error(error));\r\n                }\r\n            };\r\n        });\r\n    }\r\n    send(data) {\r\n        if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\r\n            this._logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this._logMessageContent)}.`);\r\n            this._webSocket.send(data);\r\n            return Promise.resolve();\r\n        }\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    }\r\n    stop() {\r\n        if (this._webSocket) {\r\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\r\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\r\n            this._close(undefined);\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    _close(event) {\r\n        // webSocket will be null if the transport did not start successfully\r\n        if (this._webSocket) {\r\n            // Clear websocket handlers because we are considering the socket closed now\r\n            this._webSocket.onclose = () => { };\r\n            this._webSocket.onmessage = () => { };\r\n            this._webSocket.onerror = () => { };\r\n            this._webSocket.close();\r\n            this._webSocket = undefined;\r\n        }\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\r\n        if (this.onclose) {\r\n            if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\r\n                this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason || \"no reason given\"}).`));\r\n            }\r\n            else if (event instanceof Error) {\r\n                this.onclose(event);\r\n            }\r\n            else {\r\n                this.onclose();\r\n            }\r\n        }\r\n    }\r\n    _isCloseEvent(event) {\r\n        return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\r\n    }\r\n}\r\n//# sourceMappingURL=WebSocketTransport.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\r\nimport { AggregateErrors, DisabledTransportError, FailedToNegotiateWithServerError, FailedToStartTransportError, HttpError, UnsupportedTransportError } from \"./Errors\";\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { HttpTransportType, TransferFormat } from \"./ITransport\";\r\nimport { LongPollingTransport } from \"./LongPollingTransport\";\r\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\r\nimport { Arg, createLogger, getUserAgentHeader, Platform } from \"./Utils\";\r\nimport { WebSocketTransport } from \"./WebSocketTransport\";\r\nconst MAX_REDIRECTS = 100;\r\n/** @private */\r\nexport class HttpConnection {\r\n    constructor(url, options = {}) {\r\n        this._stopPromiseResolver = () => { };\r\n        this.features = {};\r\n        this._negotiateVersion = 1;\r\n        Arg.isRequired(url, \"url\");\r\n        this._logger = createLogger(options.logger);\r\n        this.baseUrl = this._resolveUrl(url);\r\n        options = options || {};\r\n        options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\r\n        if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\r\n            options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\r\n        }\r\n        else {\r\n            throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\r\n        }\r\n        options.timeout = options.timeout === undefined ? 100 * 1000 : options.timeout;\r\n        let webSocketModule = null;\r\n        let eventSourceModule = null;\r\n        if (Platform.isNode && typeof require !== \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            webSocketModule = requireFunc(\"ws\");\r\n            eventSourceModule = requireFunc(\"eventsource\");\r\n        }\r\n        if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\r\n            options.WebSocket = WebSocket;\r\n        }\r\n        else if (Platform.isNode && !options.WebSocket) {\r\n            if (webSocketModule) {\r\n                options.WebSocket = webSocketModule;\r\n            }\r\n        }\r\n        if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\r\n            options.EventSource = EventSource;\r\n        }\r\n        else if (Platform.isNode && !options.EventSource) {\r\n            if (typeof eventSourceModule !== \"undefined\") {\r\n                options.EventSource = eventSourceModule;\r\n            }\r\n        }\r\n        this._httpClient = options.httpClient || new DefaultHttpClient(this._logger);\r\n        this._connectionState = \"Disconnected\" /* Disconnected */;\r\n        this._connectionStarted = false;\r\n        this._options = options;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    async start(transferFormat) {\r\n        transferFormat = transferFormat || TransferFormat.Binary;\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);\r\n        if (this._connectionState !== \"Disconnected\" /* Disconnected */) {\r\n            return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n        this._connectionState = \"Connecting\" /* Connecting */;\r\n        this._startInternalPromise = this._startInternal(transferFormat);\r\n        await this._startInternalPromise;\r\n        // The TypeScript compiler thinks that connectionState must be Connecting here. The TypeScript compiler is wrong.\r\n        if (this._connectionState === \"Disconnecting\" /* Disconnecting */) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"Failed to start the HttpConnection before stop() was called.\";\r\n            this._logger.log(LogLevel.Error, message);\r\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\r\n            await this._stopPromise;\r\n            return Promise.reject(new Error(message));\r\n        }\r\n        else if (this._connectionState !== \"Connected\" /* Connected */) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\r\n            this._logger.log(LogLevel.Error, message);\r\n            return Promise.reject(new Error(message));\r\n        }\r\n        this._connectionStarted = true;\r\n    }\r\n    send(data) {\r\n        if (this._connectionState !== \"Connected\" /* Connected */) {\r\n            return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\r\n        }\r\n        if (!this._sendQueue) {\r\n            this._sendQueue = new TransportSendQueue(this.transport);\r\n        }\r\n        // Transport will not be null if state is connected\r\n        return this._sendQueue.send(data);\r\n    }\r\n    async stop(error) {\r\n        if (this._connectionState === \"Disconnected\" /* Disconnected */) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n        if (this._connectionState === \"Disconnecting\" /* Disconnecting */) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this._stopPromise;\r\n        }\r\n        this._connectionState = \"Disconnecting\" /* Disconnecting */;\r\n        this._stopPromise = new Promise((resolve) => {\r\n            // Don't complete stop() until stopConnection() completes.\r\n            this._stopPromiseResolver = resolve;\r\n        });\r\n        // stopInternal should never throw so just observe it.\r\n        await this._stopInternal(error);\r\n        await this._stopPromise;\r\n    }\r\n    async _stopInternal(error) {\r\n        // Set error as soon as possible otherwise there is a race between\r\n        // the transport closing and providing an error and the error from a close message\r\n        // We would prefer the close message error.\r\n        this._stopError = error;\r\n        try {\r\n            await this._startInternalPromise;\r\n        }\r\n        catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n        // The transport's onclose will trigger stopConnection which will run our onclose event.\r\n        // The transport should always be set if currently connected. If it wasn't set, it's likely because\r\n        // stop was called during start() and start() failed.\r\n        if (this.transport) {\r\n            try {\r\n                await this.transport.stop();\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`);\r\n                this._stopConnection();\r\n            }\r\n            this.transport = undefined;\r\n        }\r\n        else {\r\n            this._logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\r\n        }\r\n    }\r\n    async _startInternal(transferFormat) {\r\n        // Store the original base url and the access token factory since they may change\r\n        // as part of negotiating\r\n        let url = this.baseUrl;\r\n        this._accessTokenFactory = this._options.accessTokenFactory;\r\n        try {\r\n            if (this._options.skipNegotiation) {\r\n                if (this._options.transport === HttpTransportType.WebSockets) {\r\n                    // No need to add a connection ID in this case\r\n                    this.transport = this._constructTransport(HttpTransportType.WebSockets);\r\n                    // We should just call connect directly in this case.\r\n                    // No fallback or negotiate in this case.\r\n                    await this._startTransport(url, transferFormat);\r\n                }\r\n                else {\r\n                    throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\r\n                }\r\n            }\r\n            else {\r\n                let negotiateResponse = null;\r\n                let redirects = 0;\r\n                do {\r\n                    negotiateResponse = await this._getNegotiationResponse(url);\r\n                    // the user tries to stop the connection when it is being started\r\n                    if (this._connectionState === \"Disconnecting\" /* Disconnecting */ || this._connectionState === \"Disconnected\" /* Disconnected */) {\r\n                        throw new Error(\"The connection was stopped during negotiation.\");\r\n                    }\r\n                    if (negotiateResponse.error) {\r\n                        throw new Error(negotiateResponse.error);\r\n                    }\r\n                    if (negotiateResponse.ProtocolVersion) {\r\n                        throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\r\n                    }\r\n                    if (negotiateResponse.url) {\r\n                        url = negotiateResponse.url;\r\n                    }\r\n                    if (negotiateResponse.accessToken) {\r\n                        // Replace the current access token factory with one that uses\r\n                        // the returned access token\r\n                        const accessToken = negotiateResponse.accessToken;\r\n                        this._accessTokenFactory = () => accessToken;\r\n                    }\r\n                    redirects++;\r\n                } while (negotiateResponse.url && redirects < MAX_REDIRECTS);\r\n                if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\r\n                    throw new Error(\"Negotiate redirection limit exceeded.\");\r\n                }\r\n                await this._createTransport(url, this._options.transport, negotiateResponse, transferFormat);\r\n            }\r\n            if (this.transport instanceof LongPollingTransport) {\r\n                this.features.inherentKeepAlive = true;\r\n            }\r\n            if (this._connectionState === \"Connecting\" /* Connecting */) {\r\n                // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\r\n                // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\r\n                this._logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\r\n                this._connectionState = \"Connected\" /* Connected */;\r\n            }\r\n            // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.\r\n            // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()\r\n            // will transition to the disconnected state. start() will wait for the transition using the stopPromise.\r\n        }\r\n        catch (e) {\r\n            this._logger.log(LogLevel.Error, \"Failed to start the connection: \" + e);\r\n            this._connectionState = \"Disconnected\" /* Disconnected */;\r\n            this.transport = undefined;\r\n            // if start fails, any active calls to stop assume that start will complete the stop promise\r\n            this._stopPromiseResolver();\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n    async _getNegotiationResponse(url) {\r\n        const headers = {};\r\n        if (this._accessTokenFactory) {\r\n            const token = await this._accessTokenFactory();\r\n            if (token) {\r\n                headers[HeaderNames.Authorization] = `Bearer ${token}`;\r\n            }\r\n        }\r\n        const [name, value] = getUserAgentHeader();\r\n        headers[name] = value;\r\n        const negotiateUrl = this._resolveNegotiateUrl(url);\r\n        this._logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}.`);\r\n        try {\r\n            const response = await this._httpClient.post(negotiateUrl, {\r\n                content: \"\",\r\n                headers: { ...headers, ...this._options.headers },\r\n                timeout: this._options.timeout,\r\n                withCredentials: this._options.withCredentials,\r\n            });\r\n            if (response.statusCode !== 200) {\r\n                return Promise.reject(new Error(`Unexpected status code returned from negotiate '${response.statusCode}'`));\r\n            }\r\n            const negotiateResponse = JSON.parse(response.content);\r\n            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\r\n                // Negotiate version 0 doesn't use connectionToken\r\n                // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\r\n                negotiateResponse.connectionToken = negotiateResponse.connectionId;\r\n            }\r\n            return negotiateResponse;\r\n        }\r\n        catch (e) {\r\n            let errorMessage = \"Failed to complete negotiation with the server: \" + e;\r\n            if (e instanceof HttpError) {\r\n                if (e.statusCode === 404) {\r\n                    errorMessage = errorMessage + \" Either this is not a SignalR endpoint or there is a proxy blocking the connection.\";\r\n                }\r\n            }\r\n            this._logger.log(LogLevel.Error, errorMessage);\r\n            return Promise.reject(new FailedToNegotiateWithServerError(errorMessage));\r\n        }\r\n    }\r\n    _createConnectUrl(url, connectionToken) {\r\n        if (!connectionToken) {\r\n            return url;\r\n        }\r\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${connectionToken}`;\r\n    }\r\n    async _createTransport(url, requestedTransport, negotiateResponse, requestedTransferFormat) {\r\n        let connectUrl = this._createConnectUrl(url, negotiateResponse.connectionToken);\r\n        if (this._isITransport(requestedTransport)) {\r\n            this._logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\r\n            this.transport = requestedTransport;\r\n            await this._startTransport(connectUrl, requestedTransferFormat);\r\n            this.connectionId = negotiateResponse.connectionId;\r\n            return;\r\n        }\r\n        const transportExceptions = [];\r\n        const transports = negotiateResponse.availableTransports || [];\r\n        let negotiate = negotiateResponse;\r\n        for (const endpoint of transports) {\r\n            const transportOrError = this._resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\r\n            if (transportOrError instanceof Error) {\r\n                // Store the error and continue, we don't want to cause a re-negotiate in these cases\r\n                transportExceptions.push(`${endpoint.transport} failed:`);\r\n                transportExceptions.push(transportOrError);\r\n            }\r\n            else if (this._isITransport(transportOrError)) {\r\n                this.transport = transportOrError;\r\n                if (!negotiate) {\r\n                    try {\r\n                        negotiate = await this._getNegotiationResponse(url);\r\n                    }\r\n                    catch (ex) {\r\n                        return Promise.reject(ex);\r\n                    }\r\n                    connectUrl = this._createConnectUrl(url, negotiate.connectionToken);\r\n                }\r\n                try {\r\n                    await this._startTransport(connectUrl, requestedTransferFormat);\r\n                    this.connectionId = negotiate.connectionId;\r\n                    return;\r\n                }\r\n                catch (ex) {\r\n                    this._logger.log(LogLevel.Error, `Failed to start the transport '${endpoint.transport}': ${ex}`);\r\n                    negotiate = undefined;\r\n                    transportExceptions.push(new FailedToStartTransportError(`${endpoint.transport} failed: ${ex}`, HttpTransportType[endpoint.transport]));\r\n                    if (this._connectionState !== \"Connecting\" /* Connecting */) {\r\n                        const message = \"Failed to select transport before stop() was called.\";\r\n                        this._logger.log(LogLevel.Debug, message);\r\n                        return Promise.reject(new Error(message));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (transportExceptions.length > 0) {\r\n            return Promise.reject(new AggregateErrors(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(\" \")}`, transportExceptions));\r\n        }\r\n        return Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\r\n    }\r\n    _constructTransport(transport) {\r\n        switch (transport) {\r\n            case HttpTransportType.WebSockets:\r\n                if (!this._options.WebSocket) {\r\n                    throw new Error(\"'WebSocket' is not supported in your environment.\");\r\n                }\r\n                return new WebSocketTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent, this._options.WebSocket, this._options.headers || {});\r\n            case HttpTransportType.ServerSentEvents:\r\n                if (!this._options.EventSource) {\r\n                    throw new Error(\"'EventSource' is not supported in your environment.\");\r\n                }\r\n                return new ServerSentEventsTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options);\r\n            case HttpTransportType.LongPolling:\r\n                return new LongPollingTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options);\r\n            default:\r\n                throw new Error(`Unknown transport: ${transport}.`);\r\n        }\r\n    }\r\n    _startTransport(url, transferFormat) {\r\n        this.transport.onreceive = this.onreceive;\r\n        this.transport.onclose = (e) => this._stopConnection(e);\r\n        return this.transport.connect(url, transferFormat);\r\n    }\r\n    _resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat) {\r\n        const transport = HttpTransportType[endpoint.transport];\r\n        if (transport === null || transport === undefined) {\r\n            this._logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n            return new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n        }\r\n        else {\r\n            if (transportMatches(requestedTransport, transport)) {\r\n                const transferFormats = endpoint.transferFormats.map((s) => TransferFormat[s]);\r\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\r\n                    if ((transport === HttpTransportType.WebSockets && !this._options.WebSocket) ||\r\n                        (transport === HttpTransportType.ServerSentEvents && !this._options.EventSource)) {\r\n                        this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`);\r\n                        return new UnsupportedTransportError(`'${HttpTransportType[transport]}' is not supported in your environment.`, transport);\r\n                    }\r\n                    else {\r\n                        this._logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'.`);\r\n                        try {\r\n                            return this._constructTransport(transport);\r\n                        }\r\n                        catch (ex) {\r\n                            return ex;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);\r\n                    return new Error(`'${HttpTransportType[transport]}' does not support ${TransferFormat[requestedTransferFormat]}.`);\r\n                }\r\n            }\r\n            else {\r\n                this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);\r\n                return new DisabledTransportError(`'${HttpTransportType[transport]}' is disabled by the client.`, transport);\r\n            }\r\n        }\r\n    }\r\n    _isITransport(transport) {\r\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\r\n    }\r\n    _stopConnection(error) {\r\n        this._logger.log(LogLevel.Debug, `HttpConnection.stopConnection(${error}) called while in state ${this._connectionState}.`);\r\n        this.transport = undefined;\r\n        // If we have a stopError, it takes precedence over the error from the transport\r\n        error = this._stopError || error;\r\n        this._stopError = undefined;\r\n        if (this._connectionState === \"Disconnected\" /* Disconnected */) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`);\r\n            return;\r\n        }\r\n        if (this._connectionState === \"Connecting\" /* Connecting */) {\r\n            this._logger.log(LogLevel.Warning, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is still in the connecting state.`);\r\n            throw new Error(`HttpConnection.stopConnection(${error}) was called while the connection is still in the connecting state.`);\r\n        }\r\n        if (this._connectionState === \"Disconnecting\" /* Disconnecting */) {\r\n            // A call to stop() induced this call to stopConnection and needs to be completed.\r\n            // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\r\n            this._stopPromiseResolver();\r\n        }\r\n        if (error) {\r\n            this._logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);\r\n        }\r\n        else {\r\n            this._logger.log(LogLevel.Information, \"Connection disconnected.\");\r\n        }\r\n        if (this._sendQueue) {\r\n            this._sendQueue.stop().catch((e) => {\r\n                this._logger.log(LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`);\r\n            });\r\n            this._sendQueue = undefined;\r\n        }\r\n        this.connectionId = undefined;\r\n        this._connectionState = \"Disconnected\" /* Disconnected */;\r\n        if (this._connectionStarted) {\r\n            this._connectionStarted = false;\r\n            try {\r\n                if (this.onclose) {\r\n                    this.onclose(error);\r\n                }\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `HttpConnection.onclose(${error}) threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n    _resolveUrl(url) {\r\n        // startsWith is not supported in IE\r\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\r\n            return url;\r\n        }\r\n        if (!Platform.isBrowser) {\r\n            throw new Error(`Cannot resolve '${url}'.`);\r\n        }\r\n        // Setting the url to the href propery of an anchor tag handles normalization\r\n        // for us. There are 3 main cases.\r\n        // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\r\n        // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\r\n        // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\r\n        const aTag = window.document.createElement(\"a\");\r\n        aTag.href = url;\r\n        this._logger.log(LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);\r\n        return aTag.href;\r\n    }\r\n    _resolveNegotiateUrl(url) {\r\n        const index = url.indexOf(\"?\");\r\n        let negotiateUrl = url.substring(0, index === -1 ? url.length : index);\r\n        if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\r\n            negotiateUrl += \"/\";\r\n        }\r\n        negotiateUrl += \"negotiate\";\r\n        negotiateUrl += index === -1 ? \"\" : url.substring(index);\r\n        if (negotiateUrl.indexOf(\"negotiateVersion\") === -1) {\r\n            negotiateUrl += index === -1 ? \"?\" : \"&\";\r\n            negotiateUrl += \"negotiateVersion=\" + this._negotiateVersion;\r\n        }\r\n        return negotiateUrl;\r\n    }\r\n}\r\nfunction transportMatches(requestedTransport, actualTransport) {\r\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\r\n}\r\n/** @private */\r\nexport class TransportSendQueue {\r\n    constructor(_transport) {\r\n        this._transport = _transport;\r\n        this._buffer = [];\r\n        this._executing = true;\r\n        this._sendBufferedData = new PromiseSource();\r\n        this._transportResult = new PromiseSource();\r\n        this._sendLoopPromise = this._sendLoop();\r\n    }\r\n    send(data) {\r\n        this._bufferData(data);\r\n        if (!this._transportResult) {\r\n            this._transportResult = new PromiseSource();\r\n        }\r\n        return this._transportResult.promise;\r\n    }\r\n    stop() {\r\n        this._executing = false;\r\n        this._sendBufferedData.resolve();\r\n        return this._sendLoopPromise;\r\n    }\r\n    _bufferData(data) {\r\n        if (this._buffer.length && typeof (this._buffer[0]) !== typeof (data)) {\r\n            throw new Error(`Expected data to be of type ${typeof (this._buffer)} but was of type ${typeof (data)}`);\r\n        }\r\n        this._buffer.push(data);\r\n        this._sendBufferedData.resolve();\r\n    }\r\n    async _sendLoop() {\r\n        while (true) {\r\n            await this._sendBufferedData.promise;\r\n            if (!this._executing) {\r\n                if (this._transportResult) {\r\n                    this._transportResult.reject(\"Connection stopped.\");\r\n                }\r\n                break;\r\n            }\r\n            this._sendBufferedData = new PromiseSource();\r\n            const transportResult = this._transportResult;\r\n            this._transportResult = undefined;\r\n            const data = typeof (this._buffer[0]) === \"string\" ?\r\n                this._buffer.join(\"\") :\r\n                TransportSendQueue._concatBuffers(this._buffer);\r\n            this._buffer.length = 0;\r\n            try {\r\n                await this._transport.send(data);\r\n                transportResult.resolve();\r\n            }\r\n            catch (error) {\r\n                transportResult.reject(error);\r\n            }\r\n        }\r\n    }\r\n    static _concatBuffers(arrayBuffers) {\r\n        const totalLength = arrayBuffers.map((b) => b.byteLength).reduce((a, b) => a + b);\r\n        const result = new Uint8Array(totalLength);\r\n        let offset = 0;\r\n        for (const item of arrayBuffers) {\r\n            result.set(new Uint8Array(item), offset);\r\n            offset += item.byteLength;\r\n        }\r\n        return result.buffer;\r\n    }\r\n}\r\nclass PromiseSource {\r\n    constructor() {\r\n        this.promise = new Promise((resolve, reject) => [this._resolver, this._rejecter] = [resolve, reject]);\r\n    }\r\n    resolve() {\r\n        this._resolver();\r\n    }\r\n    reject(reason) {\r\n        this._rejecter(reason);\r\n    }\r\n}\r\n//# sourceMappingURL=HttpConnection.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// Not exported from index\r\n/** @private */\r\nexport class TextMessageFormat {\r\n    static write(output) {\r\n        return `${output}${TextMessageFormat.RecordSeparator}`;\r\n    }\r\n    static parse(input) {\r\n        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\r\n            throw new Error(\"Message is incomplete.\");\r\n        }\r\n        const messages = input.split(TextMessageFormat.RecordSeparator);\r\n        messages.pop();\r\n        return messages;\r\n    }\r\n}\r\nTextMessageFormat.RecordSeparatorCode = 0x1e;\r\nTextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\r\n//# sourceMappingURL=TextMessageFormat.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n/** @private */\r\nexport class HandshakeProtocol {\r\n    // Handshake request is always JSON\r\n    writeHandshakeRequest(handshakeRequest) {\r\n        return TextMessageFormat.write(JSON.stringify(handshakeRequest));\r\n    }\r\n    parseHandshakeResponse(data) {\r\n        let messageData;\r\n        let remainingData;\r\n        if (isArrayBuffer(data)) {\r\n            // Format is binary but still need to read JSON text from handshake response\r\n            const binaryData = new Uint8Array(data);\r\n            const separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = String.fromCharCode.apply(null, Array.prototype.slice.call(binaryData.slice(0, responseLength)));\r\n            remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;\r\n        }\r\n        else {\r\n            const textData = data;\r\n            const separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = textData.substring(0, responseLength);\r\n            remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;\r\n        }\r\n        // At this point we should have just the single handshake message\r\n        const messages = TextMessageFormat.parse(messageData);\r\n        const response = JSON.parse(messages[0]);\r\n        if (response.type) {\r\n            throw new Error(\"Expected a handshake response from the server.\");\r\n        }\r\n        const responseMessage = response;\r\n        // multiple messages could have arrived with handshake\r\n        // return additional data to be parsed as usual, or null if all parsed\r\n        return [remainingData, responseMessage];\r\n    }\r\n}\r\n//# sourceMappingURL=HandshakeProtocol.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n/** Defines the type of a Hub Message. */\r\nexport var MessageType;\r\n(function (MessageType) {\r\n    /** Indicates the message is an Invocation message and implements the {@link @microsoft/signalr.InvocationMessage} interface. */\r\n    MessageType[MessageType[\"Invocation\"] = 1] = \"Invocation\";\r\n    /** Indicates the message is a StreamItem message and implements the {@link @microsoft/signalr.StreamItemMessage} interface. */\r\n    MessageType[MessageType[\"StreamItem\"] = 2] = \"StreamItem\";\r\n    /** Indicates the message is a Completion message and implements the {@link @microsoft/signalr.CompletionMessage} interface. */\r\n    MessageType[MessageType[\"Completion\"] = 3] = \"Completion\";\r\n    /** Indicates the message is a Stream Invocation message and implements the {@link @microsoft/signalr.StreamInvocationMessage} interface. */\r\n    MessageType[MessageType[\"StreamInvocation\"] = 4] = \"StreamInvocation\";\r\n    /** Indicates the message is a Cancel Invocation message and implements the {@link @microsoft/signalr.CancelInvocationMessage} interface. */\r\n    MessageType[MessageType[\"CancelInvocation\"] = 5] = \"CancelInvocation\";\r\n    /** Indicates the message is a Ping message and implements the {@link @microsoft/signalr.PingMessage} interface. */\r\n    MessageType[MessageType[\"Ping\"] = 6] = \"Ping\";\r\n    /** Indicates the message is a Close message and implements the {@link @microsoft/signalr.CloseMessage} interface. */\r\n    MessageType[MessageType[\"Close\"] = 7] = \"Close\";\r\n})(MessageType || (MessageType = {}));\r\n//# sourceMappingURL=IHubProtocol.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { SubjectSubscription } from \"./Utils\";\r\n/** Stream implementation to stream items to the server. */\r\nexport class Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n    next(item) {\r\n        for (const observer of this.observers) {\r\n            observer.next(item);\r\n        }\r\n    }\r\n    error(err) {\r\n        for (const observer of this.observers) {\r\n            if (observer.error) {\r\n                observer.error(err);\r\n            }\r\n        }\r\n    }\r\n    complete() {\r\n        for (const observer of this.observers) {\r\n            if (observer.complete) {\r\n                observer.complete();\r\n            }\r\n        }\r\n    }\r\n    subscribe(observer) {\r\n        this.observers.push(observer);\r\n        return new SubjectSubscription(this, observer);\r\n    }\r\n}\r\n//# sourceMappingURL=Subject.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { HandshakeProtocol } from \"./HandshakeProtocol\";\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { Subject } from \"./Subject\";\r\nimport { Arg, getErrorString, Platform } from \"./Utils\";\r\nconst DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\r\nconst DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;\r\n/** Describes the current state of the {@link HubConnection} to the server. */\r\nexport var HubConnectionState;\r\n(function (HubConnectionState) {\r\n    /** The hub connection is disconnected. */\r\n    HubConnectionState[\"Disconnected\"] = \"Disconnected\";\r\n    /** The hub connection is connecting. */\r\n    HubConnectionState[\"Connecting\"] = \"Connecting\";\r\n    /** The hub connection is connected. */\r\n    HubConnectionState[\"Connected\"] = \"Connected\";\r\n    /** The hub connection is disconnecting. */\r\n    HubConnectionState[\"Disconnecting\"] = \"Disconnecting\";\r\n    /** The hub connection is reconnecting. */\r\n    HubConnectionState[\"Reconnecting\"] = \"Reconnecting\";\r\n})(HubConnectionState || (HubConnectionState = {}));\r\n/** Represents a connection to a SignalR Hub. */\r\nexport class HubConnection {\r\n    constructor(connection, logger, protocol, reconnectPolicy) {\r\n        this._nextKeepAlive = 0;\r\n        this._freezeEventListener = () => {\r\n            this._logger.log(LogLevel.Warning, \"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://docs.microsoft.com/aspnet/core/signalr/javascript-client#bsleep\");\r\n        };\r\n        Arg.isRequired(connection, \"connection\");\r\n        Arg.isRequired(logger, \"logger\");\r\n        Arg.isRequired(protocol, \"protocol\");\r\n        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\r\n        this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\r\n        this._logger = logger;\r\n        this._protocol = protocol;\r\n        this.connection = connection;\r\n        this._reconnectPolicy = reconnectPolicy;\r\n        this._handshakeProtocol = new HandshakeProtocol();\r\n        this.connection.onreceive = (data) => this._processIncomingData(data);\r\n        this.connection.onclose = (error) => this._connectionClosed(error);\r\n        this._callbacks = {};\r\n        this._methods = {};\r\n        this._closedCallbacks = [];\r\n        this._reconnectingCallbacks = [];\r\n        this._reconnectedCallbacks = [];\r\n        this._invocationId = 0;\r\n        this._receivedHandshakeResponse = false;\r\n        this._connectionState = HubConnectionState.Disconnected;\r\n        this._connectionStarted = false;\r\n        this._cachedPingMessage = this._protocol.writeMessage({ type: MessageType.Ping });\r\n    }\r\n    /** @internal */\r\n    // Using a public static factory method means we can have a private constructor and an _internal_\r\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\r\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\r\n    // public parameter-less constructor.\r\n    static create(connection, logger, protocol, reconnectPolicy) {\r\n        return new HubConnection(connection, logger, protocol, reconnectPolicy);\r\n    }\r\n    /** Indicates the state of the {@link HubConnection} to the server. */\r\n    get state() {\r\n        return this._connectionState;\r\n    }\r\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n     *  in the disconnected state or if the negotiation step was skipped.\r\n     */\r\n    get connectionId() {\r\n        return this.connection ? (this.connection.connectionId || null) : null;\r\n    }\r\n    /** Indicates the url of the {@link HubConnection} to the server. */\r\n    get baseUrl() {\r\n        return this.connection.baseUrl || \"\";\r\n    }\r\n    /**\r\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n     * Reconnecting states.\r\n     * @param {string} url The url to connect to.\r\n     */\r\n    set baseUrl(url) {\r\n        if (this._connectionState !== HubConnectionState.Disconnected && this._connectionState !== HubConnectionState.Reconnecting) {\r\n            throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\r\n        }\r\n        if (!url) {\r\n            throw new Error(\"The HubConnection url must be a valid url.\");\r\n        }\r\n        this.connection.baseUrl = url;\r\n    }\r\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\r\n    start() {\r\n        this._startPromise = this._startWithStateTransitions();\r\n        return this._startPromise;\r\n    }\r\n    async _startWithStateTransitions() {\r\n        if (this._connectionState !== HubConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n        this._connectionState = HubConnectionState.Connecting;\r\n        this._logger.log(LogLevel.Debug, \"Starting HubConnection.\");\r\n        try {\r\n            await this._startInternal();\r\n            if (Platform.isBrowser) {\r\n                // Log when the browser freezes the tab so users know why their connection unexpectedly stopped working\r\n                window.document.addEventListener(\"freeze\", this._freezeEventListener);\r\n            }\r\n            this._connectionState = HubConnectionState.Connected;\r\n            this._connectionStarted = true;\r\n            this._logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\r\n        }\r\n        catch (e) {\r\n            this._connectionState = HubConnectionState.Disconnected;\r\n            this._logger.log(LogLevel.Debug, `HubConnection failed to start successfully because of error '${e}'.`);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n    async _startInternal() {\r\n        this._stopDuringStartError = undefined;\r\n        this._receivedHandshakeResponse = false;\r\n        // Set up the promise before any connection is (re)started otherwise it could race with received messages\r\n        const handshakePromise = new Promise((resolve, reject) => {\r\n            this._handshakeResolver = resolve;\r\n            this._handshakeRejecter = reject;\r\n        });\r\n        await this.connection.start(this._protocol.transferFormat);\r\n        try {\r\n            const handshakeRequest = {\r\n                protocol: this._protocol.name,\r\n                version: this._protocol.version,\r\n            };\r\n            this._logger.log(LogLevel.Debug, \"Sending handshake request.\");\r\n            await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(handshakeRequest));\r\n            this._logger.log(LogLevel.Information, `Using HubProtocol '${this._protocol.name}'.`);\r\n            // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n            this._cleanupTimeout();\r\n            this._resetTimeoutPeriod();\r\n            this._resetKeepAliveInterval();\r\n            await handshakePromise;\r\n            // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\r\n            // being rejected on close, because this continuation can run after both the handshake completed successfully\r\n            // and the connection was closed.\r\n            if (this._stopDuringStartError) {\r\n                // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\r\n                // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\r\n                // will cause the calling continuation to get scheduled to run later.\r\n                // eslint-disable-next-line @typescript-eslint/no-throw-literal\r\n                throw this._stopDuringStartError;\r\n            }\r\n        }\r\n        catch (e) {\r\n            this._logger.log(LogLevel.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`);\r\n            this._cleanupTimeout();\r\n            this._cleanupPingTimer();\r\n            // HttpConnection.stop() should not complete until after the onclose callback is invoked.\r\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\r\n            await this.connection.stop(e);\r\n            throw e;\r\n        }\r\n    }\r\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\r\n    async stop() {\r\n        // Capture the start promise before the connection might be restarted in an onclose callback.\r\n        const startPromise = this._startPromise;\r\n        this._stopPromise = this._stopInternal();\r\n        await this._stopPromise;\r\n        try {\r\n            // Awaiting undefined continues immediately\r\n            await startPromise;\r\n        }\r\n        catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n    }\r\n    _stopInternal(error) {\r\n        if (this._connectionState === HubConnectionState.Disconnected) {\r\n            this._logger.log(LogLevel.Debug, `Call to HubConnection.stop(${error}) ignored because it is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n        if (this._connectionState === HubConnectionState.Disconnecting) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this._stopPromise;\r\n        }\r\n        this._connectionState = HubConnectionState.Disconnecting;\r\n        this._logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\r\n        if (this._reconnectDelayHandle) {\r\n            // We're in a reconnect delay which means the underlying connection is currently already stopped.\r\n            // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\r\n            // fire the onclose callbacks.\r\n            this._logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\r\n            clearTimeout(this._reconnectDelayHandle);\r\n            this._reconnectDelayHandle = undefined;\r\n            this._completeClose();\r\n            return Promise.resolve();\r\n        }\r\n        this._cleanupTimeout();\r\n        this._cleanupPingTimer();\r\n        this._stopDuringStartError = error || new Error(\"The connection was stopped before the hub handshake could complete.\");\r\n        // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\r\n        // or the onclose callback is invoked. The onclose callback will transition the HubConnection\r\n        // to the disconnected state if need be before HttpConnection.stop() completes.\r\n        return this.connection.stop(error);\r\n    }\r\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\r\n    stream(methodName, ...args) {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const invocationDescriptor = this._createStreamInvocation(methodName, args, streamIds);\r\n        // eslint-disable-next-line prefer-const\r\n        let promiseQueue;\r\n        const subject = new Subject();\r\n        subject.cancelCallback = () => {\r\n            const cancelInvocation = this._createCancelInvocation(invocationDescriptor.invocationId);\r\n            delete this._callbacks[invocationDescriptor.invocationId];\r\n            return promiseQueue.then(() => {\r\n                return this._sendWithProtocol(cancelInvocation);\r\n            });\r\n        };\r\n        this._callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            }\r\n            else if (invocationEvent) {\r\n                // invocationEvent will not be null when an error is not passed to the callback\r\n                if (invocationEvent.type === MessageType.Completion) {\r\n                    if (invocationEvent.error) {\r\n                        subject.error(new Error(invocationEvent.error));\r\n                    }\r\n                    else {\r\n                        subject.complete();\r\n                    }\r\n                }\r\n                else {\r\n                    subject.next((invocationEvent.item));\r\n                }\r\n            }\r\n        };\r\n        promiseQueue = this._sendWithProtocol(invocationDescriptor)\r\n            .catch((e) => {\r\n            subject.error(e);\r\n            delete this._callbacks[invocationDescriptor.invocationId];\r\n        });\r\n        this._launchStreams(streams, promiseQueue);\r\n        return subject;\r\n    }\r\n    _sendMessage(message) {\r\n        this._resetKeepAliveInterval();\r\n        return this.connection.send(message);\r\n    }\r\n    /**\r\n     * Sends a js object to the server.\r\n     * @param message The js object to serialize and send.\r\n     */\r\n    _sendWithProtocol(message) {\r\n        return this._sendMessage(this._protocol.writeMessage(message));\r\n    }\r\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\r\n    send(methodName, ...args) {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const sendPromise = this._sendWithProtocol(this._createInvocation(methodName, args, true, streamIds));\r\n        this._launchStreams(streams, sendPromise);\r\n        return sendPromise;\r\n    }\r\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\r\n    invoke(methodName, ...args) {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const invocationDescriptor = this._createInvocation(methodName, args, false, streamIds);\r\n        const p = new Promise((resolve, reject) => {\r\n            // invocationId will always have a value for a non-blocking invocation\r\n            this._callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                }\r\n                else if (invocationEvent) {\r\n                    // invocationEvent will not be null when an error is not passed to the callback\r\n                    if (invocationEvent.type === MessageType.Completion) {\r\n                        if (invocationEvent.error) {\r\n                            reject(new Error(invocationEvent.error));\r\n                        }\r\n                        else {\r\n                            resolve(invocationEvent.result);\r\n                        }\r\n                    }\r\n                    else {\r\n                        reject(new Error(`Unexpected message type: ${invocationEvent.type}`));\r\n                    }\r\n                }\r\n            };\r\n            const promiseQueue = this._sendWithProtocol(invocationDescriptor)\r\n                .catch((e) => {\r\n                reject(e);\r\n                // invocationId will always have a value for a non-blocking invocation\r\n                delete this._callbacks[invocationDescriptor.invocationId];\r\n            });\r\n            this._launchStreams(streams, promiseQueue);\r\n        });\r\n        return p;\r\n    }\r\n    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n     *\r\n     * @param {string} methodName The name of the hub method to define.\r\n     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n     */\r\n    on(methodName, newMethod) {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        if (!this._methods[methodName]) {\r\n            this._methods[methodName] = [];\r\n        }\r\n        // Preventing adding the same handler multiple times.\r\n        if (this._methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n        this._methods[methodName].push(newMethod);\r\n    }\r\n    off(methodName, method) {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        const handlers = this._methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            const removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this._methods[methodName];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            delete this._methods[methodName];\r\n        }\r\n    }\r\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\r\n    onclose(callback) {\r\n        if (callback) {\r\n            this._closedCallbacks.push(callback);\r\n        }\r\n    }\r\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n     */\r\n    onreconnecting(callback) {\r\n        if (callback) {\r\n            this._reconnectingCallbacks.push(callback);\r\n        }\r\n    }\r\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n     */\r\n    onreconnected(callback) {\r\n        if (callback) {\r\n            this._reconnectedCallbacks.push(callback);\r\n        }\r\n    }\r\n    _processIncomingData(data) {\r\n        this._cleanupTimeout();\r\n        if (!this._receivedHandshakeResponse) {\r\n            data = this._processHandshakeResponse(data);\r\n            this._receivedHandshakeResponse = true;\r\n        }\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            const messages = this._protocol.parseMessages(data, this._logger);\r\n            for (const message of messages) {\r\n                switch (message.type) {\r\n                    case MessageType.Invocation:\r\n                        this._invokeClientMethod(message);\r\n                        break;\r\n                    case MessageType.StreamItem:\r\n                    case MessageType.Completion: {\r\n                        const callback = this._callbacks[message.invocationId];\r\n                        if (callback) {\r\n                            if (message.type === MessageType.Completion) {\r\n                                delete this._callbacks[message.invocationId];\r\n                            }\r\n                            try {\r\n                                callback(message);\r\n                            }\r\n                            catch (e) {\r\n                                this._logger.log(LogLevel.Error, `Stream callback threw error: ${getErrorString(e)}`);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MessageType.Ping:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case MessageType.Close: {\r\n                        this._logger.log(LogLevel.Information, \"Close message received from server.\");\r\n                        const error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\r\n                        if (message.allowReconnect === true) {\r\n                            // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\r\n                            // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\r\n                            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n                            this.connection.stop(error);\r\n                        }\r\n                        else {\r\n                            // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\r\n                            this._stopPromise = this._stopInternal(error);\r\n                        }\r\n                        break;\r\n                    }\r\n                    default:\r\n                        this._logger.log(LogLevel.Warning, `Invalid message type: ${message.type}.`);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        this._resetTimeoutPeriod();\r\n    }\r\n    _processHandshakeResponse(data) {\r\n        let responseMessage;\r\n        let remainingData;\r\n        try {\r\n            [remainingData, responseMessage] = this._handshakeProtocol.parseHandshakeResponse(data);\r\n        }\r\n        catch (e) {\r\n            const message = \"Error parsing handshake response: \" + e;\r\n            this._logger.log(LogLevel.Error, message);\r\n            const error = new Error(message);\r\n            this._handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            const message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this._logger.log(LogLevel.Error, message);\r\n            const error = new Error(message);\r\n            this._handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        else {\r\n            this._logger.log(LogLevel.Debug, \"Server handshake complete.\");\r\n        }\r\n        this._handshakeResolver();\r\n        return remainingData;\r\n    }\r\n    _resetKeepAliveInterval() {\r\n        if (this.connection.features.inherentKeepAlive) {\r\n            return;\r\n        }\r\n        // Set the time we want the next keep alive to be sent\r\n        // Timer will be setup on next message receive\r\n        this._nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;\r\n        this._cleanupPingTimer();\r\n    }\r\n    _resetTimeoutPeriod() {\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this._timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);\r\n            // Set keepAlive timer if there isn't one\r\n            if (this._pingServerHandle === undefined) {\r\n                let nextPing = this._nextKeepAlive - new Date().getTime();\r\n                if (nextPing < 0) {\r\n                    nextPing = 0;\r\n                }\r\n                // The timer needs to be set from a networking callback to avoid Chrome timer throttling from causing timers to run once a minute\r\n                this._pingServerHandle = setTimeout(async () => {\r\n                    if (this._connectionState === HubConnectionState.Connected) {\r\n                        try {\r\n                            await this._sendMessage(this._cachedPingMessage);\r\n                        }\r\n                        catch {\r\n                            // We don't care about the error. It should be seen elsewhere in the client.\r\n                            // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\r\n                            this._cleanupPingTimer();\r\n                        }\r\n                    }\r\n                }, nextPing);\r\n            }\r\n        }\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    serverTimeout() {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    }\r\n    _invokeClientMethod(invocationMessage) {\r\n        const methods = this._methods[invocationMessage.target.toLowerCase()];\r\n        if (methods) {\r\n            try {\r\n                methods.forEach((m) => m.apply(this, invocationMessage.arguments));\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `A callback for the method ${invocationMessage.target.toLowerCase()} threw error '${e}'.`);\r\n            }\r\n            if (invocationMessage.invocationId) {\r\n                // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\r\n                const message = \"Server requested a response, which is not supported in this version of the client.\";\r\n                this._logger.log(LogLevel.Error, message);\r\n                // We don't want to wait on the stop itself.\r\n                this._stopPromise = this._stopInternal(new Error(message));\r\n            }\r\n        }\r\n        else {\r\n            this._logger.log(LogLevel.Warning, `No client method with the name '${invocationMessage.target}' found.`);\r\n        }\r\n    }\r\n    _connectionClosed(error) {\r\n        this._logger.log(LogLevel.Debug, `HubConnection.connectionClosed(${error}) called while in state ${this._connectionState}.`);\r\n        // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\r\n        this._stopDuringStartError = this._stopDuringStartError || error || new Error(\"The underlying connection was closed before the hub handshake could complete.\");\r\n        // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\r\n        // If it has already completed, this should just noop.\r\n        if (this._handshakeResolver) {\r\n            this._handshakeResolver();\r\n        }\r\n        this._cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\r\n        this._cleanupTimeout();\r\n        this._cleanupPingTimer();\r\n        if (this._connectionState === HubConnectionState.Disconnecting) {\r\n            this._completeClose(error);\r\n        }\r\n        else if (this._connectionState === HubConnectionState.Connected && this._reconnectPolicy) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._reconnect(error);\r\n        }\r\n        else if (this._connectionState === HubConnectionState.Connected) {\r\n            this._completeClose(error);\r\n        }\r\n        // If none of the above if conditions were true were called the HubConnection must be in either:\r\n        // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\r\n        // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\r\n        //    and potentially continue the reconnect() loop.\r\n        // 3. The Disconnected state in which case we're already done.\r\n    }\r\n    _completeClose(error) {\r\n        if (this._connectionStarted) {\r\n            this._connectionState = HubConnectionState.Disconnected;\r\n            this._connectionStarted = false;\r\n            if (Platform.isBrowser) {\r\n                window.document.removeEventListener(\"freeze\", this._freezeEventListener);\r\n            }\r\n            try {\r\n                this._closedCallbacks.forEach((c) => c.apply(this, [error]));\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `An onclose callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n    async _reconnect(error) {\r\n        const reconnectStartTime = Date.now();\r\n        let previousReconnectAttempts = 0;\r\n        let retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\r\n        let nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\r\n        if (nextRetryDelay === null) {\r\n            this._logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\r\n            this._completeClose(error);\r\n            return;\r\n        }\r\n        this._connectionState = HubConnectionState.Reconnecting;\r\n        if (error) {\r\n            this._logger.log(LogLevel.Information, `Connection reconnecting because of error '${error}'.`);\r\n        }\r\n        else {\r\n            this._logger.log(LogLevel.Information, \"Connection reconnecting.\");\r\n        }\r\n        if (this._reconnectingCallbacks.length !== 0) {\r\n            try {\r\n                this._reconnectingCallbacks.forEach((c) => c.apply(this, [error]));\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `An onreconnecting callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n            // Exit early if an onreconnecting callback called connection.stop().\r\n            if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\r\n                return;\r\n            }\r\n        }\r\n        while (nextRetryDelay !== null) {\r\n            this._logger.log(LogLevel.Information, `Reconnect attempt number ${previousReconnectAttempts} will start in ${nextRetryDelay} ms.`);\r\n            await new Promise((resolve) => {\r\n                this._reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);\r\n            });\r\n            this._reconnectDelayHandle = undefined;\r\n            if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\r\n                return;\r\n            }\r\n            try {\r\n                await this._startInternal();\r\n                this._connectionState = HubConnectionState.Connected;\r\n                this._logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\r\n                if (this._reconnectedCallbacks.length !== 0) {\r\n                    try {\r\n                        this._reconnectedCallbacks.forEach((c) => c.apply(this, [this.connection.connectionId]));\r\n                    }\r\n                    catch (e) {\r\n                        this._logger.log(LogLevel.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`);\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Information, `Reconnect attempt failed because of error '${e}'.`);\r\n                if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                    this._logger.log(LogLevel.Debug, `Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`);\r\n                    // The TypeScript compiler thinks that connectionState must be Connected here. The TypeScript compiler is wrong.\r\n                    if (this._connectionState === HubConnectionState.Disconnecting) {\r\n                        this._completeClose();\r\n                    }\r\n                    return;\r\n                }\r\n                retryError = e instanceof Error ? e : new Error(e.toString());\r\n                nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\r\n            }\r\n        }\r\n        this._logger.log(LogLevel.Information, `Reconnect retries have been exhausted after ${Date.now() - reconnectStartTime} ms and ${previousReconnectAttempts} failed attempts. Connection disconnecting.`);\r\n        this._completeClose();\r\n    }\r\n    _getNextRetryDelay(previousRetryCount, elapsedMilliseconds, retryReason) {\r\n        try {\r\n            return this._reconnectPolicy.nextRetryDelayInMilliseconds({\r\n                elapsedMilliseconds,\r\n                previousRetryCount,\r\n                retryReason,\r\n            });\r\n        }\r\n        catch (e) {\r\n            this._logger.log(LogLevel.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${previousRetryCount}, ${elapsedMilliseconds}) threw error '${e}'.`);\r\n            return null;\r\n        }\r\n    }\r\n    _cancelCallbacksWithError(error) {\r\n        const callbacks = this._callbacks;\r\n        this._callbacks = {};\r\n        Object.keys(callbacks)\r\n            .forEach((key) => {\r\n            const callback = callbacks[key];\r\n            try {\r\n                callback(null, error);\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `Stream 'error' callback called with '${error}' threw error: ${getErrorString(e)}`);\r\n            }\r\n        });\r\n    }\r\n    _cleanupPingTimer() {\r\n        if (this._pingServerHandle) {\r\n            clearTimeout(this._pingServerHandle);\r\n            this._pingServerHandle = undefined;\r\n        }\r\n    }\r\n    _cleanupTimeout() {\r\n        if (this._timeoutHandle) {\r\n            clearTimeout(this._timeoutHandle);\r\n        }\r\n    }\r\n    _createInvocation(methodName, args, nonblocking, streamIds) {\r\n        if (nonblocking) {\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    arguments: args,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        }\r\n        else {\r\n            const invocationId = this._invocationId;\r\n            this._invocationId++;\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        }\r\n    }\r\n    _launchStreams(streams, promiseQueue) {\r\n        if (streams.length === 0) {\r\n            return;\r\n        }\r\n        // Synchronize stream data so they arrive in-order on the server\r\n        if (!promiseQueue) {\r\n            promiseQueue = Promise.resolve();\r\n        }\r\n        // We want to iterate over the keys, since the keys are the stream ids\r\n        // eslint-disable-next-line guard-for-in\r\n        for (const streamId in streams) {\r\n            streams[streamId].subscribe({\r\n                complete: () => {\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId)));\r\n                },\r\n                error: (err) => {\r\n                    let message;\r\n                    if (err instanceof Error) {\r\n                        message = err.message;\r\n                    }\r\n                    else if (err && err.toString) {\r\n                        message = err.toString();\r\n                    }\r\n                    else {\r\n                        message = \"Unknown error\";\r\n                    }\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId, message)));\r\n                },\r\n                next: (item) => {\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createStreamItemMessage(streamId, item)));\r\n                },\r\n            });\r\n        }\r\n    }\r\n    _replaceStreamingParams(args) {\r\n        const streams = [];\r\n        const streamIds = [];\r\n        for (let i = 0; i < args.length; i++) {\r\n            const argument = args[i];\r\n            if (this._isObservable(argument)) {\r\n                const streamId = this._invocationId;\r\n                this._invocationId++;\r\n                // Store the stream for later use\r\n                streams[streamId] = argument;\r\n                streamIds.push(streamId.toString());\r\n                // remove stream from args\r\n                args.splice(i, 1);\r\n            }\r\n        }\r\n        return [streams, streamIds];\r\n    }\r\n    _isObservable(arg) {\r\n        // This allows other stream implementations to just work (like rxjs)\r\n        return arg && arg.subscribe && typeof arg.subscribe === \"function\";\r\n    }\r\n    _createStreamInvocation(methodName, args, streamIds) {\r\n        const invocationId = this._invocationId;\r\n        this._invocationId++;\r\n        if (streamIds.length !== 0) {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                streamIds,\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        }\r\n    }\r\n    _createCancelInvocation(id) {\r\n        return {\r\n            invocationId: id,\r\n            type: MessageType.CancelInvocation,\r\n        };\r\n    }\r\n    _createStreamItemMessage(id, item) {\r\n        return {\r\n            invocationId: id,\r\n            item,\r\n            type: MessageType.StreamItem,\r\n        };\r\n    }\r\n    _createCompletionMessage(id, error, result) {\r\n        if (error) {\r\n            return {\r\n                error,\r\n                invocationId: id,\r\n                type: MessageType.Completion,\r\n            };\r\n        }\r\n        return {\r\n            invocationId: id,\r\n            result,\r\n            type: MessageType.Completion,\r\n        };\r\n    }\r\n}\r\n//# sourceMappingURL=HubConnection.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\nconst JSON_HUB_PROTOCOL_NAME = \"json\";\r\n/** Implements the JSON Hub Protocol. */\r\nexport class JsonHubProtocol {\r\n    constructor() {\r\n        /** @inheritDoc */\r\n        this.name = JSON_HUB_PROTOCOL_NAME;\r\n        /** @inheritDoc */\r\n        this.version = 1;\r\n        /** @inheritDoc */\r\n        this.transferFormat = TransferFormat.Text;\r\n    }\r\n    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n     *\r\n     * @param {string} input A string containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    parseMessages(input, logger) {\r\n        // The interface does allow \"ArrayBuffer\" to be passed in, but this implementation does not. So let's throw a useful error.\r\n        if (typeof input !== \"string\") {\r\n            throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\r\n        }\r\n        if (!input) {\r\n            return [];\r\n        }\r\n        if (logger === null) {\r\n            logger = NullLogger.instance;\r\n        }\r\n        // Parse the messages\r\n        const messages = TextMessageFormat.parse(input);\r\n        const hubMessages = [];\r\n        for (const message of messages) {\r\n            const parsedMessage = JSON.parse(message);\r\n            if (typeof parsedMessage.type !== \"number\") {\r\n                throw new Error(\"Invalid payload.\");\r\n            }\r\n            switch (parsedMessage.type) {\r\n                case MessageType.Invocation:\r\n                    this._isInvocationMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.StreamItem:\r\n                    this._isStreamItemMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Completion:\r\n                    this._isCompletionMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Ping:\r\n                    // Single value, no need to validate\r\n                    break;\r\n                case MessageType.Close:\r\n                    // All optional values, no need to validate\r\n                    break;\r\n                default:\r\n                    // Future protocol changes can add message types, old clients can ignore them\r\n                    logger.log(LogLevel.Information, \"Unknown message type '\" + parsedMessage.type + \"' ignored.\");\r\n                    continue;\r\n            }\r\n            hubMessages.push(parsedMessage);\r\n        }\r\n        return hubMessages;\r\n    }\r\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string} A string containing the serialized representation of the message.\r\n     */\r\n    writeMessage(message) {\r\n        return TextMessageFormat.write(JSON.stringify(message));\r\n    }\r\n    _isInvocationMessage(message) {\r\n        this._assertNotEmptyString(message.target, \"Invalid payload for Invocation message.\");\r\n        if (message.invocationId !== undefined) {\r\n            this._assertNotEmptyString(message.invocationId, \"Invalid payload for Invocation message.\");\r\n        }\r\n    }\r\n    _isStreamItemMessage(message) {\r\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for StreamItem message.\");\r\n        if (message.item === undefined) {\r\n            throw new Error(\"Invalid payload for StreamItem message.\");\r\n        }\r\n    }\r\n    _isCompletionMessage(message) {\r\n        if (message.result && message.error) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n        if (!message.result && message.error) {\r\n            this._assertNotEmptyString(message.error, \"Invalid payload for Completion message.\");\r\n        }\r\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for Completion message.\");\r\n    }\r\n    _assertNotEmptyString(value, errorMessage) {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            throw new Error(errorMessage);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=JsonHubProtocol.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { DefaultReconnectPolicy } from \"./DefaultReconnectPolicy\";\r\nimport { HttpConnection } from \"./HttpConnection\";\r\nimport { HubConnection } from \"./HubConnection\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { JsonHubProtocol } from \"./JsonHubProtocol\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { Arg, ConsoleLogger } from \"./Utils\";\r\nconst LogLevelNameMapping = {\r\n    trace: LogLevel.Trace,\r\n    debug: LogLevel.Debug,\r\n    info: LogLevel.Information,\r\n    information: LogLevel.Information,\r\n    warn: LogLevel.Warning,\r\n    warning: LogLevel.Warning,\r\n    error: LogLevel.Error,\r\n    critical: LogLevel.Critical,\r\n    none: LogLevel.None,\r\n};\r\nfunction parseLogLevel(name) {\r\n    // Case-insensitive matching via lower-casing\r\n    // Yes, I know case-folding is a complicated problem in Unicode, but we only support\r\n    // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.\r\n    const mapping = LogLevelNameMapping[name.toLowerCase()];\r\n    if (typeof mapping !== \"undefined\") {\r\n        return mapping;\r\n    }\r\n    else {\r\n        throw new Error(`Unknown log level: ${name}`);\r\n    }\r\n}\r\n/** A builder for configuring {@link @microsoft/signalr.HubConnection} instances. */\r\nexport class HubConnectionBuilder {\r\n    configureLogging(logging) {\r\n        Arg.isRequired(logging, \"logging\");\r\n        if (isLogger(logging)) {\r\n            this.logger = logging;\r\n        }\r\n        else if (typeof logging === \"string\") {\r\n            const logLevel = parseLogLevel(logging);\r\n            this.logger = new ConsoleLogger(logLevel);\r\n        }\r\n        else {\r\n            this.logger = new ConsoleLogger(logging);\r\n        }\r\n        return this;\r\n    }\r\n    withUrl(url, transportTypeOrOptions) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isNotEmpty(url, \"url\");\r\n        this.url = url;\r\n        // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed\r\n        // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.\r\n        if (typeof transportTypeOrOptions === \"object\") {\r\n            this.httpConnectionOptions = { ...this.httpConnectionOptions, ...transportTypeOrOptions };\r\n        }\r\n        else {\r\n            this.httpConnectionOptions = {\r\n                ...this.httpConnectionOptions,\r\n                transport: transportTypeOrOptions,\r\n            };\r\n        }\r\n        return this;\r\n    }\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.\r\n     *\r\n     * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.\r\n     */\r\n    withHubProtocol(protocol) {\r\n        Arg.isRequired(protocol, \"protocol\");\r\n        this.protocol = protocol;\r\n        return this;\r\n    }\r\n    withAutomaticReconnect(retryDelaysOrReconnectPolicy) {\r\n        if (this.reconnectPolicy) {\r\n            throw new Error(\"A reconnectPolicy has already been set.\");\r\n        }\r\n        if (!retryDelaysOrReconnectPolicy) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy();\r\n        }\r\n        else if (Array.isArray(retryDelaysOrReconnectPolicy)) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);\r\n        }\r\n        else {\r\n            this.reconnectPolicy = retryDelaysOrReconnectPolicy;\r\n        }\r\n        return this;\r\n    }\r\n    /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.\r\n     *\r\n     * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.\r\n     */\r\n    build() {\r\n        // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one\r\n        // provided to configureLogger\r\n        const httpConnectionOptions = this.httpConnectionOptions || {};\r\n        // If it's 'null', the user **explicitly** asked for null, don't mess with it.\r\n        if (httpConnectionOptions.logger === undefined) {\r\n            // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.\r\n            httpConnectionOptions.logger = this.logger;\r\n        }\r\n        // Now create the connection\r\n        if (!this.url) {\r\n            throw new Error(\"The 'HubConnectionBuilder.withUrl' method must be called before building the connection.\");\r\n        }\r\n        const connection = new HttpConnection(this.url, httpConnectionOptions);\r\n        return HubConnection.create(connection, this.logger || NullLogger.instance, this.protocol || new JsonHubProtocol(), this.reconnectPolicy);\r\n    }\r\n}\r\nfunction isLogger(logger) {\r\n    return logger.log !== undefined;\r\n}\r\n//# sourceMappingURL=HubConnectionBuilder.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n/** A logger that does nothing when log messages are sent to it. */\r\nexport class NullLogger {\r\n    constructor() { }\r\n    /** @inheritDoc */\r\n    // eslint-disable-next-line\r\n    log(_logLevel, _message) {\r\n    }\r\n}\r\n/** The singleton instance of the {@link @microsoft/signalr.NullLogger}. */\r\nNullLogger.instance = new NullLogger();\r\n//# sourceMappingURL=Loggers.js.map","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"\\n    relative\\n    z-10\\n    flex-shrink-0\\n    h-16\\n    w-full\\n    border-b border-gray-200\\n    flex\\n  \"},[_c('button',{staticClass:\"\\n      border-r border-gray-200\\n      px-4\\n      text-gray-500\\n      focus:outline-none\\n      focus:ring-2 focus:ring-inset focus:ring-indigo-500\\n      md:hidden\\n    \",on:{\"click\":function($event){_vm.toggleMenu = !_vm.toggleMenu}}},[_c('span',{staticClass:\"sr-only\"},[_vm._v(\"Open sidebar\")]),_c('svg',{staticClass:\"h-6 w-6\",attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"fill\":\"none\",\"viewBox\":\"0 0 24 24\",\"stroke\":\"currentColor\",\"aria-hidden\":\"true\"}},[_c('path',{attrs:{\"stroke-linecap\":\"round\",\"stroke-linejoin\":\"round\",\"stroke-width\":\"2\",\"d\":\"M4 6h16M4 12h16M4 18h7\"}})])]),_c('div',{staticClass:\"flex-1 flex justify-between items-center px-4 md:px-0\"},[(_vm.roles.includes('d'))?_c('router-link',{staticClass:\"border border-black duration-300 bg-white px-4 py-2 rounded-md text-gray-900 font-bold hover:bg-green-600 hover:text-white focus:outline-none\",attrs:{\"to\":{ name: 'sent-add' }}},[_vm._v(\" إضافة بريد جديد + \")]):_vm._e(),_c('div',{staticClass:\"relative md:mr-6 ml-4\"},[_c('div',[_c('button',{staticClass:\"\\n            max-w-xs\\n            flex\\n            items-center\\n            text-sm\\n            rounded-full\\n            focus:outline-none\\n            focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500\\n          \",attrs:{\"type\":\"button\",\"id\":\"user-menu-button\",\"aria-expanded\":\"false\",\"aria-haspopup\":\"true\"},on:{\"click\":_vm.Logout}},[_c('span',{staticClass:\"sr-only\"},[_vm._v(\"Logout\")]),_c('svg',{staticClass:\"w-6 h-6\",attrs:{\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"xmlns\":\"http://www.w3.org/2000/svg\"}},[_c('path',{attrs:{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":\"{2}\",\"d\":\"M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1\"}})])])]),(_vm.userProcedure)?_c('div',{staticClass:\"\\n          origin-top-left\\n          absolute\\n          left-0\\n          mt-2\\n          w-48\\n          rounded-md\\n          shadow-lg\\n          bg-white\\n          ring-1 ring-black ring-opacity-5\\n          py-1\\n          focus:outline-none\\n        \",attrs:{\"role\":\"menu\",\"aria-orientation\":\"vertical\",\"aria-labelledby\":\"user-menu-button\",\"tabindex\":\"-1\"}},[_c('a',{staticClass:\"block py-2 px-4 text-sm text-gray-700\",attrs:{\"href\":\"#\",\"role\":\"menuitem\",\"tabindex\":\"-1\",\"id\":\"user-menu-item-0\"}},[_vm._v(\"الملف الشخصي\")]),_c('a',{staticClass:\"block py-2 px-4 text-sm text-gray-700\",attrs:{\"href\":\"#\",\"role\":\"menuitem\",\"tabindex\":\"-1\",\"id\":\"user-menu-item-1\"}},[_vm._v(\"الإعدادات\")]),_c('a',{staticClass:\"block py-2 px-4 text-sm text-gray-700\",attrs:{\"href\":\"#\",\"role\":\"menuitem\",\"tabindex\":\"-1\",\"id\":\"user-menu-item-2\"}},[_vm._v(\"خروج\")])]):_vm._e()])],1)])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\r\n  <div\r\n    class=\"\r\n      relative\r\n      z-10\r\n      flex-shrink-0\r\n      h-16\r\n      w-full\r\n      border-b border-gray-200\r\n      flex\r\n    \"\r\n  >\r\n    <button\r\n      @click=\"toggleMenu = !toggleMenu\"\r\n      class=\"\r\n        border-r border-gray-200\r\n        px-4\r\n        text-gray-500\r\n        focus:outline-none\r\n        focus:ring-2 focus:ring-inset focus:ring-indigo-500\r\n        md:hidden\r\n      \"\r\n    >\r\n      <span class=\"sr-only\">Open sidebar</span>\r\n      <!-- Heroicon name: outline/menu-alt-2 -->\r\n      <svg\r\n        class=\"h-6 w-6\"\r\n        xmlns=\"http://www.w3.org/2000/svg\"\r\n        fill=\"none\"\r\n        viewBox=\"0 0 24 24\"\r\n        stroke=\"currentColor\"\r\n        aria-hidden=\"true\"\r\n      >\r\n        <path\r\n          stroke-linecap=\"round\"\r\n          stroke-linejoin=\"round\"\r\n          stroke-width=\"2\"\r\n          d=\"M4 6h16M4 12h16M4 18h7\"\r\n        />\r\n      </svg>\r\n    </button>\r\n    <div class=\"flex-1 flex justify-between items-center px-4 md:px-0\">\r\n      <!-- <a :href=\"$router.resolve({ name: 'sent-add' }).href\"  class=\"border border-black duration-300 bg-white px-4 py-2 rounded-md text-gray-900 font-bold hover:bg-green-600 hover:text-white focus:outline-none\">\r\n        إضافة بريد جديد +\r\n      </a> -->\r\n\r\n      <router-link\r\n        v-if=\"roles.includes('d')\"\r\n        :to=\"{ name: 'sent-add' }\"\r\n        class=\"border border-black duration-300 bg-white px-4 py-2 rounded-md text-gray-900 font-bold hover:bg-green-600 hover:text-white focus:outline-none\"\r\n      >\r\n        إضافة بريد جديد +\r\n      </router-link>\r\n\r\n      <!-- search -->\r\n\r\n      <!-- <div class=\"w-full flex items-center \">\r\n        <fieldset class=\"w-2/5 ml-6\">\r\n          <div class=\"flex items-center\">\r\n            <legend class=\"text-base font-semibold text-gray-800 ml-6\">\r\n              نوع البريد\r\n            </legend>\r\n            <div class=\"flex justify-between items-center\">\r\n              <div class=\"flex items-center\">\r\n                <input\r\n                  v-model=\"mailType\"\r\n                  id=\"internal\"\r\n                  type=\"radio\"\r\n                  name=\"type\"\r\n                  class=\"h-4 w-4\"\r\n                  value=\"1\"\r\n                />\r\n                <label for=\"internal\" class=\"mr-2 block text-gray-800\">\r\n                  داخلي\r\n                </label>\r\n              </div>\r\n\r\n              <div class=\"flex items-center mx-4\">\r\n                <input\r\n                  v-model=\"mailType\"\r\n                  id=\"internal_export\"\r\n                  type=\"radio\"\r\n                  name=\"type\"\r\n                  class=\"h-4 w-4\"\r\n                  value=\"2\"\r\n                />\r\n                <label for=\"internal_export\" class=\"mr-2 block text-gray-800\">\r\n                  صادر خارجي\r\n                </label>\r\n              </div>\r\n\r\n              <div class=\"flex items-center\">\r\n                <input\r\n                  v-model=\"mailType\"\r\n                  id=\"external_incoming\"\r\n                  type=\"radio\"\r\n                  name=\"type\"\r\n                  class=\"h-4 w-4\"\r\n                  value=\"3\"\r\n                />\r\n                <label for=\"external_incoming\" class=\"mr-2 block text-gray-800\">\r\n                  وارد خارجي\r\n                </label>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </fieldset>\r\n\r\n        <input type=\"number\" class=\"w-16 px-1 rounded-md focus:outline-none \">\r\n\r\n        <input type=\"number\" class=\"w-16 px-1 rounded-md focus:outline-none mx-4\" v-model=\"my_department_id\">\r\n\r\n        <input type=\"number\" class=\"w-16 px-1 rounded-md focus:outline-none \" v-model=\"year\">\r\n\r\n      </div> -->\r\n\r\n      <!-- Profile dropdown -->\r\n      <div class=\"relative md:mr-6 ml-4\">\r\n        <div>\r\n          <!--  @click=\"userProcedure = !userProcedure\" -->\r\n          <button\r\n            type=\"button\"\r\n            class=\"\r\n              max-w-xs\r\n              flex\r\n              items-center\r\n              text-sm\r\n              rounded-full\r\n              focus:outline-none\r\n              focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500\r\n            \"\r\n            @click=\"Logout\"\r\n            id=\"user-menu-button\"\r\n            aria-expanded=\"false\"\r\n            aria-haspopup=\"true\"\r\n          >\r\n            <span class=\"sr-only\">Logout</span>\r\n            <svg\r\n              class=\"w-6 h-6\"\r\n              fill=\"none\"\r\n              stroke=\"currentColor\"\r\n              viewBox=\"0 0 24 24\"\r\n              xmlns=\"http://www.w3.org/2000/svg\"\r\n            >\r\n              <path\r\n                strokeLinecap=\"round\"\r\n                strokeLinejoin=\"round\"\r\n                strokeWidth=\"{2}\"\r\n                d=\"M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1\"\r\n              />\r\n            </svg>\r\n\r\n            <!-- <img class=\"h-8 w-8 rounded-full\" src=\"https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?ixlib=rb-1.2.1&ixqx=9iaFDkXMqu&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80\" alt=\"\"> -->\r\n          </button>\r\n        </div>\r\n\r\n        <!--\r\n                            Dropdown menu, show/hide based on menu state.\r\n\r\n                            Entering: \"transition ease-out duration-100\"\r\n                                From: \"transform opacity-0 scale-95\"\r\n                                To: \"transform opacity-100 scale-100\"\r\n                            Leaving: \"transition ease-in duration-75\"\r\n                                From: \"transform opacity-100 scale-100\"\r\n                                To: \"transform opacity-0 scale-95\"\r\n                            -->\r\n        <div\r\n          v-if=\"userProcedure\"\r\n          class=\"\r\n            origin-top-left\r\n            absolute\r\n            left-0\r\n            mt-2\r\n            w-48\r\n            rounded-md\r\n            shadow-lg\r\n            bg-white\r\n            ring-1 ring-black ring-opacity-5\r\n            py-1\r\n            focus:outline-none\r\n          \"\r\n          role=\"menu\"\r\n          aria-orientation=\"vertical\"\r\n          aria-labelledby=\"user-menu-button\"\r\n          tabindex=\"-1\"\r\n        >\r\n          <!-- Active: \"bg-gray-100\", Not Active: \"\" -->\r\n          <a\r\n            href=\"#\"\r\n            class=\"block py-2 px-4 text-sm text-gray-700\"\r\n            role=\"menuitem\"\r\n            tabindex=\"-1\"\r\n            id=\"user-menu-item-0\"\r\n            >الملف الشخصي</a\r\n          >\r\n\r\n          <a\r\n            href=\"#\"\r\n            class=\"block py-2 px-4 text-sm text-gray-700\"\r\n            role=\"menuitem\"\r\n            tabindex=\"-1\"\r\n            id=\"user-menu-item-1\"\r\n            >الإعدادات</a\r\n          >\r\n\r\n          <a\r\n            href=\"#\"\r\n            class=\"block py-2 px-4 text-sm text-gray-700\"\r\n            role=\"menuitem\"\r\n            tabindex=\"-1\"\r\n            id=\"user-menu-item-2\"\r\n            >خروج</a\r\n          >\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  mounted() {\r\n    if (localStorage.getItem(\"AY_LW\") == null) {\r\n      this.$router.push(\"/\");\r\n    }\r\n\r\n    var date = new Date();\r\n\r\n    // var month = date.getMonth() +1;\r\n\r\n    // if (month < 10) month = \"0\" + month;\r\n\r\n    // this.date_from = date.getFullYear()+ \"-\" +month+ \"-\" +date.getDate()\r\n    // this.date_to = date.getFullYear()+ \"-\" +month+ \"-\" +date.getDate()\r\n\r\n    this.year = date.getFullYear();\r\n    this.my_user_id = localStorage.getItem(\"AY_LW\");\r\n    this.my_department_id = localStorage.getItem(\"chrome\");\r\n    this.roles = localStorage.getItem(\"Az07\");\r\n  },\r\n\r\n  data() {\r\n    return {\r\n      roles: [],\r\n      my_user_id: \"\",\r\n      my_department_id: \"\",\r\n      year: \"\",\r\n      userProcedure: false,\r\n      toggleMenu: false,\r\n\r\n      searchMenu: false,\r\n      closeSearchMenu: false,\r\n\r\n      searchFor: \"\",\r\n\r\n      resultOfSearch: \"\",\r\n\r\n      finacial_recipt_number: {},\r\n\r\n      transaction_number: {},\r\n\r\n      mailType: 1,\r\n    };\r\n  },\r\n\r\n  methods: {\r\n    Logout() {\r\n      localStorage.removeItem(\"AY_LW\");\r\n      localStorage.removeItem(\"chrome\");\r\n      localStorage.removeItem(\"Az07\");\r\n      this.$router.push(\"/\");\r\n    },\r\n    search() {\r\n      this.closeSearchMenu = true;\r\n\r\n      if (this.searchFor == \"\") {\r\n        this.searchMenu = false;\r\n        this.closeSearchMenu = false;\r\n        return;\r\n      }\r\n\r\n      this.searchMenu = true;\r\n      var text = this.searchFor;\r\n\r\n      this.$http.TransactionsService.ayoub(text)\r\n        .then((res) => {\r\n          this.resultOfSearch = res.data;\r\n\r\n          this.finacial_recipt_number = this.resultOfSearch.finacial_recipt_number;\r\n          this.transaction_number = this.resultOfSearch.transaction_number;\r\n\r\n          if (\r\n            this.finacial_recipt_number == 0 &&\r\n            this.transaction_number == 0\r\n          ) {\r\n            this.searchMenu = false;\r\n          }\r\n        })\r\n        .catch((err) => {\r\n          console.log(err);\r\n        });\r\n    },\r\n\r\n    canselSearch() {\r\n      this.searchFor = \"\";\r\n      this.searchMenu = false;\r\n      this.closeSearchMenu = false;\r\n    },\r\n\r\n    toggle_menu() {\r\n      document.querySelector(\"#overlay\").classList.toggle(\"hidden\");\r\n      document.body.classList.toggle(\"overflow-y-hidden\");\r\n      document.getElementById(\"menu\").classList.toggle(\"hidden\");\r\n    },\r\n\r\n    toggle_search() {\r\n      document.querySelector(\"#overlaySearch\").classList.toggle(\"hidden\");\r\n      document.body.classList.toggle(\"overflow-y-hidden\");\r\n      document.getElementById(\"searchMobile\").classList.toggle(\"hidden\");\r\n    },\r\n  },\r\n};\r\n</script>\r\n\r\n<style></style>\r\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./navComponent.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./navComponent.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./navComponent.vue?vue&type=template&id=4a90febe&\"\nimport script from \"./navComponent.vue?vue&type=script&lang=js&\"\nexport * from \"./navComponent.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}